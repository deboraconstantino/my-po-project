import * as tslib_1 from "tslib";
import { Directive, TemplateRef } from '@angular/core';
/**
 * @usedBy PoSlideComponent
 *
 * @description
 *
 * Esta diretiva permite a customização de um slide.
 *
 * Deve-se utilizar como parâmetro a referência do item e/ou índice, sendo por padrão o item.
 *  - Item: `item` determina o item do slide corrente.
 *  - Índice: `index` determina o índice do slide corrente.
 *
 * Esta diretiva pode ser usada de duas formas: explícita ou *syntax sugar*. Veja a seguir ambos, respectivamente:
 *
 * ```
 * ...
 * <po-slide
 *   [p-slides]="[{ id: 1, name: 'Register', email: 'register@portinari.com' }]">
 *
 *   <ng-template p-slide-content-template let-item let-code="index">
 *     <div class="po-row">
 *       <po-info class="po-md-6" p-label="Code" [p-value]="item.id"></po-info>
 *       <po-info class="po-md-6" p-label="Email" [p-value]="item.email"></po-info>
 *     </div>
 *   </ng-template>
 *
 * </po-slide>
 *
 * ...
 * ```
 *
 * ```
 * ...
 * <po-slide
 *    [p-slides]="[{ id: 1, name: 'Register', email: 'register@portinari.com' }]">
 *
 *    <div *p-slide-content-template="let item, let i=index" class="po-row">
 *      <po-info class="po-md-12" p-label="Email" [p-value]="item.email"></po-info>
 *    </div>
 * </po-slide>
 * ...
 *
 * ```
 */
let PoSlideContentTemplateDirective = class PoSlideContentTemplateDirective {
    // Necessário manter templateRef para o funcionamento do row template.
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
PoSlideContentTemplateDirective.ctorParameters = () => [
    { type: TemplateRef }
];
PoSlideContentTemplateDirective = tslib_1.__decorate([
    Directive({
        selector: '[p-slide-content-template]'
    }),
    tslib_1.__metadata("design:paramtypes", [TemplateRef])
], PoSlideContentTemplateDirective);
export { PoSlideContentTemplateDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tc2xpZGUtY29udGVudC10ZW1wbGF0ZS5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AcG9ydGluYXJpL3BvcnRpbmFyaS11aS8iLCJzb3VyY2VzIjpbImxpYi9jb21wb25lbnRzL3BvLXNsaWRlL2RpcmVjdGl2ZXMvcG8tc2xpZGUtY29udGVudC10ZW1wbGF0ZS5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsV0FBVyxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRXZEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0EwQ0c7QUFJSCxJQUFhLCtCQUErQixHQUE1QyxNQUFhLCtCQUErQjtJQUUxQyxzRUFBc0U7SUFDdEUsWUFBbUIsV0FBNkI7UUFBN0IsZ0JBQVcsR0FBWCxXQUFXLENBQWtCO0lBQUksQ0FBQztDQUN0RCxDQUFBOztZQURpQyxXQUFXOztBQUhoQywrQkFBK0I7SUFIM0MsU0FBUyxDQUFDO1FBQ1QsUUFBUSxFQUFFLDRCQUE0QjtLQUN2QyxDQUFDOzZDQUlnQyxXQUFXO0dBSGhDLCtCQUErQixDQUkzQztTQUpZLCtCQUErQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBAdXNlZEJ5IFBvU2xpZGVDb21wb25lbnRcbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBFc3RhIGRpcmV0aXZhIHBlcm1pdGUgYSBjdXN0b21pemHDp8OjbyBkZSB1bSBzbGlkZS5cbiAqXG4gKiBEZXZlLXNlIHV0aWxpemFyIGNvbW8gcGFyw6JtZXRybyBhIHJlZmVyw6puY2lhIGRvIGl0ZW0gZS9vdSDDrW5kaWNlLCBzZW5kbyBwb3IgcGFkcsOjbyBvIGl0ZW0uXG4gKiAgLSBJdGVtOiBgaXRlbWAgZGV0ZXJtaW5hIG8gaXRlbSBkbyBzbGlkZSBjb3JyZW50ZS5cbiAqICAtIMONbmRpY2U6IGBpbmRleGAgZGV0ZXJtaW5hIG8gw61uZGljZSBkbyBzbGlkZSBjb3JyZW50ZS5cbiAqXG4gKiBFc3RhIGRpcmV0aXZhIHBvZGUgc2VyIHVzYWRhIGRlIGR1YXMgZm9ybWFzOiBleHBsw61jaXRhIG91ICpzeW50YXggc3VnYXIqLiBWZWphIGEgc2VndWlyIGFtYm9zLCByZXNwZWN0aXZhbWVudGU6XG4gKlxuICogYGBgXG4gKiAuLi5cbiAqIDxwby1zbGlkZVxuICogICBbcC1zbGlkZXNdPVwiW3sgaWQ6IDEsIG5hbWU6ICdSZWdpc3RlcicsIGVtYWlsOiAncmVnaXN0ZXJAcG9ydGluYXJpLmNvbScgfV1cIj5cbiAqXG4gKiAgIDxuZy10ZW1wbGF0ZSBwLXNsaWRlLWNvbnRlbnQtdGVtcGxhdGUgbGV0LWl0ZW0gbGV0LWNvZGU9XCJpbmRleFwiPlxuICogICAgIDxkaXYgY2xhc3M9XCJwby1yb3dcIj5cbiAqICAgICAgIDxwby1pbmZvIGNsYXNzPVwicG8tbWQtNlwiIHAtbGFiZWw9XCJDb2RlXCIgW3AtdmFsdWVdPVwiaXRlbS5pZFwiPjwvcG8taW5mbz5cbiAqICAgICAgIDxwby1pbmZvIGNsYXNzPVwicG8tbWQtNlwiIHAtbGFiZWw9XCJFbWFpbFwiIFtwLXZhbHVlXT1cIml0ZW0uZW1haWxcIj48L3BvLWluZm8+XG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvbmctdGVtcGxhdGU+XG4gKlxuICogPC9wby1zbGlkZT5cbiAqXG4gKiAuLi5cbiAqIGBgYFxuICpcbiAqIGBgYFxuICogLi4uXG4gKiA8cG8tc2xpZGVcbiAqICAgIFtwLXNsaWRlc109XCJbeyBpZDogMSwgbmFtZTogJ1JlZ2lzdGVyJywgZW1haWw6ICdyZWdpc3RlckBwb3J0aW5hcmkuY29tJyB9XVwiPlxuICpcbiAqICAgIDxkaXYgKnAtc2xpZGUtY29udGVudC10ZW1wbGF0ZT1cImxldCBpdGVtLCBsZXQgaT1pbmRleFwiIGNsYXNzPVwicG8tcm93XCI+XG4gKiAgICAgIDxwby1pbmZvIGNsYXNzPVwicG8tbWQtMTJcIiBwLWxhYmVsPVwiRW1haWxcIiBbcC12YWx1ZV09XCJpdGVtLmVtYWlsXCI+PC9wby1pbmZvPlxuICogICAgPC9kaXY+XG4gKiA8L3BvLXNsaWRlPlxuICogLi4uXG4gKlxuICogYGBgXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1twLXNsaWRlLWNvbnRlbnQtdGVtcGxhdGVdJ1xufSlcbmV4cG9ydCBjbGFzcyBQb1NsaWRlQ29udGVudFRlbXBsYXRlRGlyZWN0aXZlIHtcblxuICAvLyBOZWNlc3PDoXJpbyBtYW50ZXIgdGVtcGxhdGVSZWYgcGFyYSBvIGZ1bmNpb25hbWVudG8gZG8gcm93IHRlbXBsYXRlLlxuICBjb25zdHJ1Y3RvcihwdWJsaWMgdGVtcGxhdGVSZWY6IFRlbXBsYXRlUmVmPGFueT4pIHsgfVxufVxuIl19