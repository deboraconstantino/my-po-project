import * as tslib_1 from "tslib";
import { EventEmitter, Input, Output } from '@angular/core';
import { convertToBoolean } from '../../utils/util';
import { PoStepperOrientation } from './enums/po-stepper-orientation.enum';
import { PoStepperStatus } from './enums/po-stepper-status.enum';
const poStepperOrientationDefault = PoStepperOrientation.Horizontal;
/**
 * @description
 *
 * O `po-stepper` permite que um processo seja dividido em passos para que o usuário o realize
 * mais facilmente.
 *
 * Existem duas formas de utilização:
 *
 * 1 - Usando o componente [**po-step**](/documentation/po-step) para renderizar e descrever os passos.
 *
 * 2 - Através da propriedade `p-steps` para descrever os passos do processo, sendo responsabilidade do desenvolvedor o controle
 * de renderização do que será exibido a cada *step* ativo.
 *
 * Através de suas propriedades, é possível definir se sua orientação será horizontal ou vertical,
 * além da possibilidade de aumentar o tamanho dos *steps*.
 *
 * Também é possível navegar entre os *steps* através do teclado utilizando a tecla *tab* e, para ativar o *step* em foco basta
 * pressionar a tecla *enter*. Além disso, é possível ativar a exibição de ícones no lugar de números nos *steps* através da
 * propriedade [`p-step-icons`](/documentation/po-stepper#stepIconsProperty).
 *
 * #### Utilizando os métodos do componente:
 *
 * Para acessar os métodos do componente é necessário ter a referência do mesmo.
 *
 * Por exemplo, utilizando um [**ViewChild**](https://angular.io/api/core/ViewChild):
 *
 * ```
 * @ViewChild(PoStepperComponent) poStepperComponent: PoStepperComponent;
 * ```
 *
 * E para acessar o método:
 *
 * ```
 * poStepperComponent.next();
 * ```
 *
 * #### Boas práticas
 *
 * - Evite `labels` extensos que quebram o layout do `po-stepper`, use `labels` diretos, curtos e intuitivos.
 * - Utilize apenas um `po-stepper` por página.
 */
export class PoStepperBaseComponent {
    constructor() {
        this._orientation = poStepperOrientationDefault;
        this._sequential = true;
        this._step = 1;
        this._steps = [];
        /** Ação que será executada quando o usuário mudar o passo do `po-stepper`. */
        this.onChangeStep = new EventEmitter();
    }
    /**
     * @optional
     *
     * @description
     *
     * Define a orientação de exibição do `po-stepper`.
     *
     * > Veja os valores válidos no *enum* [PoStepperOrientation](documentation/po-stepper#stepperOrientation).
     *
     * @default `PoStepperOrientation.Horizontal`
     */
    set orientation(value) {
        this._orientation = Object.values(PoStepperOrientation).includes(value) ? value : poStepperOrientationDefault;
    }
    get orientation() {
        return this._orientation;
    }
    /**
     * @optional
     *
     * @description
     *
     * Controla o passo atual do `po-stepper`.
     *
     * > Ao utilizar esta propriedade e também utilizar o componente [**po-step**](/documentation/po-step),
     * o valor desta propriedade será ignorada permanecendo a definição do [**po-step**](/documentation/po-step).
     *
     * @default `1`
     */
    set step(step) {
        if (step >= 1 && step <= this.steps.length) {
            this._step = step;
            this._steps[this._step - 1].status = PoStepperStatus.Active;
        }
    }
    get step() {
        return this._step;
    }
    /**
     * @optional
     *
     * @description
     *
     * Lista dos itens do stepper. Se o valor estiver indefinido ou inválido, será inicializado como um array vazio.
     *
     * > Ao utilizar esta propriedade e também utilizar o componente [**po-step**](/documentation/po-step),
     * o valor desta propriedade será ignorada permanecendo a definição do [**po-step**](/documentation/po-step).
     */
    set steps(steps) {
        this._steps = Array.isArray(steps) ? steps : [];
        this._steps.forEach(step => step.status = PoStepperStatus.Default);
        this.step = 1;
    }
    get steps() {
        return this._steps;
    }
    /**
     * @optional
     *
     * @description
     *
     * Define se o `po-stepper` será sequencial ou aleatório.
     *
     * > Ao utilizar o componente [**po-step**](/documentation/po-step), o valor desta propriedade sempre será verdadeiro.
     *
     * @default `true`
     */
    set sequential(sequential) {
        this._sequential = convertToBoolean(sequential);
    }
    get sequential() {
        return this._sequential;
    }
}
tslib_1.__decorate([
    Input('p-orientation'),
    tslib_1.__metadata("design:type", String),
    tslib_1.__metadata("design:paramtypes", [String])
], PoStepperBaseComponent.prototype, "orientation", null);
tslib_1.__decorate([
    Input('p-step'),
    tslib_1.__metadata("design:type", Number),
    tslib_1.__metadata("design:paramtypes", [Number])
], PoStepperBaseComponent.prototype, "step", null);
tslib_1.__decorate([
    Input('p-steps'),
    tslib_1.__metadata("design:type", Array),
    tslib_1.__metadata("design:paramtypes", [Array])
], PoStepperBaseComponent.prototype, "steps", null);
tslib_1.__decorate([
    Input('p-step-icons'),
    tslib_1.__metadata("design:type", Boolean)
], PoStepperBaseComponent.prototype, "stepIcons", void 0);
tslib_1.__decorate([
    Input('p-step-size'),
    tslib_1.__metadata("design:type", Number)
], PoStepperBaseComponent.prototype, "stepSize", void 0);
tslib_1.__decorate([
    Input('p-sequential'),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [Boolean])
], PoStepperBaseComponent.prototype, "sequential", null);
tslib_1.__decorate([
    Output('p-change-step'),
    tslib_1.__metadata("design:type", Object)
], PoStepperBaseComponent.prototype, "onChangeStep", void 0);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tc3RlcHBlci1iYXNlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bwb3J0aW5hcmkvcG9ydGluYXJpLXVpLyIsInNvdXJjZXMiOlsibGliL2NvbXBvbmVudHMvcG8tc3RlcHBlci9wby1zdGVwcGVyLWJhc2UuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFNUQsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFJcEQsT0FBTyxFQUFFLG9CQUFvQixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFDM0UsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBRWpFLE1BQU0sMkJBQTJCLEdBQUcsb0JBQW9CLENBQUMsVUFBVSxDQUFDO0FBRXBFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBd0NHO0FBQ0gsTUFBTSxPQUFPLHNCQUFzQjtJQUFuQztRQUVVLGlCQUFZLEdBQTBCLDJCQUEyQixDQUFDO1FBQ2xFLGdCQUFXLEdBQWEsSUFBSSxDQUFDO1FBQzdCLFVBQUssR0FBVyxDQUFDLENBQUM7UUFDbEIsV0FBTSxHQUF5QixFQUFFLENBQUM7UUFnSDFDLDhFQUE4RTtRQUNyRCxpQkFBWSxHQUFHLElBQUksWUFBWSxFQUE0QixDQUFDO0lBRXZGLENBQUM7SUFqSEM7Ozs7Ozs7Ozs7T0FVRztJQUNxQixJQUFJLFdBQVcsQ0FBQyxLQUEyQjtRQUNqRSxJQUFJLENBQUMsWUFBWSxHQUFTLE1BQU8sQ0FBQyxNQUFNLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsMkJBQTJCLENBQUM7SUFDdkgsQ0FBQztJQUVELElBQUksV0FBVztRQUNiLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQztJQUMzQixDQUFDO0lBRUQ7Ozs7Ozs7Ozs7O09BV0c7SUFDYyxJQUFJLElBQUksQ0FBQyxJQUFZO1FBQ3BDLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUU7WUFDMUMsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7WUFDbEIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxlQUFlLENBQUMsTUFBTSxDQUFDO1NBQzdEO0lBQ0gsQ0FBQztJQUVELElBQUksSUFBSTtRQUNOLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztJQUNwQixDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ2UsSUFBSSxLQUFLLENBQUMsS0FBMkI7UUFDckQsSUFBSSxDQUFDLE1BQU0sR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztRQUNoRCxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsZUFBZSxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ25FLElBQUksQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO0lBQ2hCLENBQUM7SUFFRCxJQUFJLEtBQUs7UUFDUCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDckIsQ0FBQztJQStCRDs7Ozs7Ozs7OztPQVVHO0lBQ29CLElBQUksVUFBVSxDQUFDLFVBQW1CO1FBQ3ZELElBQUksQ0FBQyxXQUFXLEdBQUcsZ0JBQWdCLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDbEQsQ0FBQztJQUVELElBQUksVUFBVTtRQUNaLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQztJQUMxQixDQUFDO0NBS0Y7QUF0R3lCO0lBQXZCLEtBQUssQ0FBQyxlQUFlLENBQUM7Ozt5REFFdEI7QUFrQmdCO0lBQWhCLEtBQUssQ0FBQyxRQUFRLENBQUM7OztrREFLZjtBQWdCaUI7SUFBakIsS0FBSyxDQUFDLFNBQVMsQ0FBQztzQ0FBa0IsS0FBSzs2Q0FBTCxLQUFLO21EQUl2QztBQWtCc0I7SUFBdEIsS0FBSyxDQUFDLGNBQWMsQ0FBQzs7eURBQW9CO0FBZXBCO0lBQXJCLEtBQUssQ0FBQyxhQUFhLENBQUM7O3dEQUFrQjtBQWFoQjtJQUF0QixLQUFLLENBQUMsY0FBYyxDQUFDOzs7d0RBRXJCO0FBT3dCO0lBQXhCLE1BQU0sQ0FBQyxlQUFlLENBQUM7OzREQUE2RCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50RW1pdHRlciwgSW5wdXQsIE91dHB1dCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG5pbXBvcnQgeyBjb252ZXJ0VG9Cb29sZWFuIH0gZnJvbSAnLi4vLi4vdXRpbHMvdXRpbCc7XG5cbmltcG9ydCB7IFBvU3RlcENvbXBvbmVudCB9IGZyb20gJy4vcG8tc3RlcC9wby1zdGVwLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQb1N0ZXBwZXJJdGVtIH0gZnJvbSAnLi9wby1zdGVwcGVyLWl0ZW0uaW50ZXJmYWNlJztcbmltcG9ydCB7IFBvU3RlcHBlck9yaWVudGF0aW9uIH0gZnJvbSAnLi9lbnVtcy9wby1zdGVwcGVyLW9yaWVudGF0aW9uLmVudW0nO1xuaW1wb3J0IHsgUG9TdGVwcGVyU3RhdHVzIH0gZnJvbSAnLi9lbnVtcy9wby1zdGVwcGVyLXN0YXR1cy5lbnVtJztcblxuY29uc3QgcG9TdGVwcGVyT3JpZW50YXRpb25EZWZhdWx0ID0gUG9TdGVwcGVyT3JpZW50YXRpb24uSG9yaXpvbnRhbDtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb25cbiAqXG4gKiBPIGBwby1zdGVwcGVyYCBwZXJtaXRlIHF1ZSB1bSBwcm9jZXNzbyBzZWphIGRpdmlkaWRvIGVtIHBhc3NvcyBwYXJhIHF1ZSBvIHVzdcOhcmlvIG8gcmVhbGl6ZVxuICogbWFpcyBmYWNpbG1lbnRlLlxuICpcbiAqIEV4aXN0ZW0gZHVhcyBmb3JtYXMgZGUgdXRpbGl6YcOnw6NvOlxuICpcbiAqIDEgLSBVc2FuZG8gbyBjb21wb25lbnRlIFsqKnBvLXN0ZXAqKl0oL2RvY3VtZW50YXRpb24vcG8tc3RlcCkgcGFyYSByZW5kZXJpemFyIGUgZGVzY3JldmVyIG9zIHBhc3Nvcy5cbiAqXG4gKiAyIC0gQXRyYXbDqXMgZGEgcHJvcHJpZWRhZGUgYHAtc3RlcHNgIHBhcmEgZGVzY3JldmVyIG9zIHBhc3NvcyBkbyBwcm9jZXNzbywgc2VuZG8gcmVzcG9uc2FiaWxpZGFkZSBkbyBkZXNlbnZvbHZlZG9yIG8gY29udHJvbGVcbiAqIGRlIHJlbmRlcml6YcOnw6NvIGRvIHF1ZSBzZXLDoSBleGliaWRvIGEgY2FkYSAqc3RlcCogYXRpdm8uXG4gKlxuICogQXRyYXbDqXMgZGUgc3VhcyBwcm9wcmllZGFkZXMsIMOpIHBvc3PDrXZlbCBkZWZpbmlyIHNlIHN1YSBvcmllbnRhw6fDo28gc2Vyw6EgaG9yaXpvbnRhbCBvdSB2ZXJ0aWNhbCxcbiAqIGFsw6ltIGRhIHBvc3NpYmlsaWRhZGUgZGUgYXVtZW50YXIgbyB0YW1hbmhvIGRvcyAqc3RlcHMqLlxuICpcbiAqIFRhbWLDqW0gw6kgcG9zc8OtdmVsIG5hdmVnYXIgZW50cmUgb3MgKnN0ZXBzKiBhdHJhdsOpcyBkbyB0ZWNsYWRvIHV0aWxpemFuZG8gYSB0ZWNsYSAqdGFiKiBlLCBwYXJhIGF0aXZhciBvICpzdGVwKiBlbSBmb2NvIGJhc3RhXG4gKiBwcmVzc2lvbmFyIGEgdGVjbGEgKmVudGVyKi4gQWzDqW0gZGlzc28sIMOpIHBvc3PDrXZlbCBhdGl2YXIgYSBleGliacOnw6NvIGRlIMOtY29uZXMgbm8gbHVnYXIgZGUgbsO6bWVyb3Mgbm9zICpzdGVwcyogYXRyYXbDqXMgZGFcbiAqIHByb3ByaWVkYWRlIFtgcC1zdGVwLWljb25zYF0oL2RvY3VtZW50YXRpb24vcG8tc3RlcHBlciNzdGVwSWNvbnNQcm9wZXJ0eSkuXG4gKlxuICogIyMjIyBVdGlsaXphbmRvIG9zIG3DqXRvZG9zIGRvIGNvbXBvbmVudGU6XG4gKlxuICogUGFyYSBhY2Vzc2FyIG9zIG3DqXRvZG9zIGRvIGNvbXBvbmVudGUgw6kgbmVjZXNzw6FyaW8gdGVyIGEgcmVmZXLDqm5jaWEgZG8gbWVzbW8uXG4gKlxuICogUG9yIGV4ZW1wbG8sIHV0aWxpemFuZG8gdW0gWyoqVmlld0NoaWxkKipdKGh0dHBzOi8vYW5ndWxhci5pby9hcGkvY29yZS9WaWV3Q2hpbGQpOlxuICpcbiAqIGBgYFxuICogQFZpZXdDaGlsZChQb1N0ZXBwZXJDb21wb25lbnQpIHBvU3RlcHBlckNvbXBvbmVudDogUG9TdGVwcGVyQ29tcG9uZW50O1xuICogYGBgXG4gKlxuICogRSBwYXJhIGFjZXNzYXIgbyBtw6l0b2RvOlxuICpcbiAqIGBgYFxuICogcG9TdGVwcGVyQ29tcG9uZW50Lm5leHQoKTtcbiAqIGBgYFxuICpcbiAqICMjIyMgQm9hcyBwcsOhdGljYXNcbiAqXG4gKiAtIEV2aXRlIGBsYWJlbHNgIGV4dGVuc29zIHF1ZSBxdWVicmFtIG8gbGF5b3V0IGRvIGBwby1zdGVwcGVyYCwgdXNlIGBsYWJlbHNgIGRpcmV0b3MsIGN1cnRvcyBlIGludHVpdGl2b3MuXG4gKiAtIFV0aWxpemUgYXBlbmFzIHVtIGBwby1zdGVwcGVyYCBwb3IgcMOhZ2luYS5cbiAqL1xuZXhwb3J0IGNsYXNzIFBvU3RlcHBlckJhc2VDb21wb25lbnQge1xuXG4gIHByaXZhdGUgX29yaWVudGF0aW9uPzogUG9TdGVwcGVyT3JpZW50YXRpb24gPSBwb1N0ZXBwZXJPcmllbnRhdGlvbkRlZmF1bHQ7XG4gIHByaXZhdGUgX3NlcXVlbnRpYWw/OiBib29sZWFuID0gdHJ1ZTtcbiAgcHJpdmF0ZSBfc3RlcDogbnVtYmVyID0gMTtcbiAgcHJpdmF0ZSBfc3RlcHM6IEFycmF5PFBvU3RlcHBlckl0ZW0+ID0gW107XG5cbiAgLyoqXG4gICAqIEBvcHRpb25hbFxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICpcbiAgICogRGVmaW5lIGEgb3JpZW50YcOnw6NvIGRlIGV4aWJpw6fDo28gZG8gYHBvLXN0ZXBwZXJgLlxuICAgKlxuICAgKiA+IFZlamEgb3MgdmFsb3JlcyB2w6FsaWRvcyBubyAqZW51bSogW1BvU3RlcHBlck9yaWVudGF0aW9uXShkb2N1bWVudGF0aW9uL3BvLXN0ZXBwZXIjc3RlcHBlck9yaWVudGF0aW9uKS5cbiAgICpcbiAgICogQGRlZmF1bHQgYFBvU3RlcHBlck9yaWVudGF0aW9uLkhvcml6b250YWxgXG4gICAqL1xuICBASW5wdXQoJ3Atb3JpZW50YXRpb24nKSBzZXQgb3JpZW50YXRpb24odmFsdWU6IFBvU3RlcHBlck9yaWVudGF0aW9uKSB7XG4gICAgdGhpcy5fb3JpZW50YXRpb24gPSAoPGFueT5PYmplY3QpLnZhbHVlcyhQb1N0ZXBwZXJPcmllbnRhdGlvbikuaW5jbHVkZXModmFsdWUpID8gdmFsdWUgOiBwb1N0ZXBwZXJPcmllbnRhdGlvbkRlZmF1bHQ7XG4gIH1cblxuICBnZXQgb3JpZW50YXRpb24oKTogUG9TdGVwcGVyT3JpZW50YXRpb24ge1xuICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIENvbnRyb2xhIG8gcGFzc28gYXR1YWwgZG8gYHBvLXN0ZXBwZXJgLlxuICAgKlxuICAgKiA+IEFvIHV0aWxpemFyIGVzdGEgcHJvcHJpZWRhZGUgZSB0YW1iw6ltIHV0aWxpemFyIG8gY29tcG9uZW50ZSBbKipwby1zdGVwKipdKC9kb2N1bWVudGF0aW9uL3BvLXN0ZXApLFxuICAgKiBvIHZhbG9yIGRlc3RhIHByb3ByaWVkYWRlIHNlcsOhIGlnbm9yYWRhIHBlcm1hbmVjZW5kbyBhIGRlZmluacOnw6NvIGRvIFsqKnBvLXN0ZXAqKl0oL2RvY3VtZW50YXRpb24vcG8tc3RlcCkuXG4gICAqXG4gICAqIEBkZWZhdWx0IGAxYFxuICAgKi9cbiAgQElucHV0KCdwLXN0ZXAnKSBzZXQgc3RlcChzdGVwOiBudW1iZXIpIHtcbiAgICBpZiAoc3RlcCA+PSAxICYmIHN0ZXAgPD0gdGhpcy5zdGVwcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3N0ZXAgPSBzdGVwO1xuICAgICAgdGhpcy5fc3RlcHNbdGhpcy5fc3RlcCAtIDFdLnN0YXR1cyA9IFBvU3RlcHBlclN0YXR1cy5BY3RpdmU7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHN0ZXAoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fc3RlcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIExpc3RhIGRvcyBpdGVucyBkbyBzdGVwcGVyLiBTZSBvIHZhbG9yIGVzdGl2ZXIgaW5kZWZpbmlkbyBvdSBpbnbDoWxpZG8sIHNlcsOhIGluaWNpYWxpemFkbyBjb21vIHVtIGFycmF5IHZhemlvLlxuICAgKlxuICAgKiA+IEFvIHV0aWxpemFyIGVzdGEgcHJvcHJpZWRhZGUgZSB0YW1iw6ltIHV0aWxpemFyIG8gY29tcG9uZW50ZSBbKipwby1zdGVwKipdKC9kb2N1bWVudGF0aW9uL3BvLXN0ZXApLFxuICAgKiBvIHZhbG9yIGRlc3RhIHByb3ByaWVkYWRlIHNlcsOhIGlnbm9yYWRhIHBlcm1hbmVjZW5kbyBhIGRlZmluacOnw6NvIGRvIFsqKnBvLXN0ZXAqKl0oL2RvY3VtZW50YXRpb24vcG8tc3RlcCkuXG4gICAqL1xuICBASW5wdXQoJ3Atc3RlcHMnKSBzZXQgc3RlcHMoc3RlcHM6IEFycmF5PFBvU3RlcHBlckl0ZW0+KSB7XG4gICAgdGhpcy5fc3RlcHMgPSBBcnJheS5pc0FycmF5KHN0ZXBzKSA/IHN0ZXBzIDogW107XG4gICAgdGhpcy5fc3RlcHMuZm9yRWFjaChzdGVwID0+IHN0ZXAuc3RhdHVzID0gUG9TdGVwcGVyU3RhdHVzLkRlZmF1bHQpO1xuICAgIHRoaXMuc3RlcCA9IDE7XG4gIH1cblxuICBnZXQgc3RlcHMoKTogQXJyYXk8UG9TdGVwcGVySXRlbT4ge1xuICAgIHJldHVybiB0aGlzLl9zdGVwcztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIDxhIGlkPVwic3RlcEljb25zUHJvcGVydHlcIj48L2E+XG4gICAqXG4gICAqIEhhYmlsaXRhIGEgZXhpYmnDp8OjbyBkZSDDrWNvbmUgYW8gaW52w6lzIGRlIG7Dum1lcm8gbm8gY2VudHJvIGRvIGPDrXJjdWxvIGRvcyAqc3RlcHMqLlxuICAgKlxuICAgKiBAZGVmYXVsdCBgZmFsc2VgXG4gICAqL1xuICBASW5wdXQoJ3Atc3RlcC1pY29ucycpIHN0ZXBJY29uczogYm9vbGVhbjtcblxuICAvKipcbiAgICogQG9wdGlvbmFsXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKlxuICAgKiBEZWZpbmUgbyB0YW1hbmhvIGRvcyAqc3RlcHMqIGVtICpwaXhlbHMqLCBwb3NzaWJpbGl0YW5kbyB1bSBtYWlvciBkZXN0YXF1ZS5cbiAgICpcbiAgICogTyB2YWxvciBpbmZvcm1hZG8gZGV2ZSBzZXIgZW50cmUgYDI0YCBlIGA2NGAuXG4gICAqXG4gICAqID4gVmFsb3JlcyBxdWUgbsOjbyBzZSBlbnF1YWRyYXJlbSBhIGVzdGEgcmVncmEgc2Vyw6NvIGlnbm9yYWRvcywgbWFudGVuZG8tc2UgbyB2YWxvciAqZGVmYXVsdCouXG4gICAqXG4gICAqIEBkZWZhdWx0IGAyNGBcbiAgICovXG4gIEBJbnB1dCgncC1zdGVwLXNpemUnKSBzdGVwU2l6ZTogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBAb3B0aW9uYWxcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqXG4gICAqIERlZmluZSBzZSBvIGBwby1zdGVwcGVyYCBzZXLDoSBzZXF1ZW5jaWFsIG91IGFsZWF0w7NyaW8uXG4gICAqXG4gICAqID4gQW8gdXRpbGl6YXIgbyBjb21wb25lbnRlIFsqKnBvLXN0ZXAqKl0oL2RvY3VtZW50YXRpb24vcG8tc3RlcCksIG8gdmFsb3IgZGVzdGEgcHJvcHJpZWRhZGUgc2VtcHJlIHNlcsOhIHZlcmRhZGVpcm8uXG4gICAqXG4gICAqIEBkZWZhdWx0IGB0cnVlYFxuICAgKi9cbiAgQElucHV0KCdwLXNlcXVlbnRpYWwnKSBzZXQgc2VxdWVudGlhbChzZXF1ZW50aWFsOiBib29sZWFuKSB7XG4gICAgdGhpcy5fc2VxdWVudGlhbCA9IGNvbnZlcnRUb0Jvb2xlYW4oc2VxdWVudGlhbCk7XG4gIH1cblxuICBnZXQgc2VxdWVudGlhbCgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fc2VxdWVudGlhbDtcbiAgfVxuXG4gIC8qKiBBw6fDo28gcXVlIHNlcsOhIGV4ZWN1dGFkYSBxdWFuZG8gbyB1c3XDoXJpbyBtdWRhciBvIHBhc3NvIGRvIGBwby1zdGVwcGVyYC4gKi9cbiAgQE91dHB1dCgncC1jaGFuZ2Utc3RlcCcpIG9uQ2hhbmdlU3RlcCA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyIHwgUG9TdGVwQ29tcG9uZW50PigpO1xuXG59XG4iXX0=