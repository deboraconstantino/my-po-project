import * as tslib_1 from "tslib";
import { Injectable } from '@angular/core';
import { sortValues } from '../../utils/util';
/**
 * @docsPrivate
 *
 * @description
 *
 * Serviço responsável por gerenciar o tratamento dos formatos de data e hora.
 */
let PoDateService = class PoDateService {
    /**
     * @docsPrivate
     *
     * @description
     *
     * Serviço responsável por gerenciar o tratamento dos formatos de data e hora.
     */
    constructor() {
        this.dateRegex = new RegExp('^(?:[0-9])\\d{1}(?:[0-9])\\d{1}-' +
            '(?:0[1-9]|1[0-2])-' +
            '(?:0[1-9]|[12]\\d|3[01])$');
        this.isoRegex = new RegExp('^(?:[0-9])\\d{1}(?:[0-9])\\d{1}-' +
            '(?:0[1-9]|1[0-2])-' +
            '(?:0[1-9]|[12]\\d|3[01])' +
            'T(?:[01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d(?:Z|-0[1-9]|-1\\d|-2[0-3]|' +
            '-00:?(?:0[1-9]|[0-5]\\d)|\\+[01]\\d|\\+2[0-3])' +
            '(?:|:?[0-5]\\d)$');
    }
    /**
     * Método responsável por converter datas do formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` para o formato `Date`.
     *
     * @param dateString Data no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param minDate Definir `true` caso seja `minDate`.
     * @param maxDate Definir `true` caso seja `maxDate`.
     */
    convertIsoToDate(dateString, minDate, maxDate) {
        if (dateString) {
            const { year, month, day } = this.getDateFromIso(dateString);
            if (minDate) {
                const date = new Date(year, month - 1, day, 0, 0, 0);
                this.setYearFrom0To100(date, year);
                return date;
            }
            else if (maxDate) {
                const date = new Date(year, month - 1, day, 23, 59, 59);
                this.setYearFrom0To100(date, year);
                return date;
            }
            else {
                const miliseconds = Date.parse(dateString);
                const timezone = new Date().getTimezoneOffset() * 60000;
                return new Date(miliseconds + timezone);
            }
        }
    }
    /**
     * Método responsável por converter data do formato `Date` para o formato `yyyy-mm-dd`.
     *
     * @param date Data no formato `Date`.
     */
    convertDateToISO(date) {
        if (date) {
            const fullYear = date.getFullYear();
            const getMonth = date.getMonth() + 1;
            const day = date.getDate() < 10 ? '0' + date.getDate() : date.getDate();
            const month = getMonth < 10 ? '0' + getMonth : getMonth;
            const year = this.formatYear(fullYear);
            return year + '-' + month + '-' + day;
        }
        else {
            return null;
        }
    }
    /**
     * Método responsável por adicionar zeros a esquerda do anos em formato string.
     *
     * @param year Ano a ser validado.
     */
    formatYear(year) {
        if (year > 999) {
            return year.toString();
        }
        if (year > 99 && year < 1000) {
            return `0${year}`;
        }
        if (year > 9 && year < 100) {
            return `00${year}`;
        }
        if (year >= 0 && year < 10) {
            return `000${year}`;
        }
    }
    /**
     * Método responsável por retornar o dia, mês e ano separados em formato de objeto.
     *
     * @param isoDate Ano em formato string.
     */
    getDateFromIso(isoDate) {
        const day = parseInt(isoDate.substring(8, 10), 10);
        const month = parseInt(isoDate.substring(5, 7), 10);
        const year = parseInt(isoDate.substring(0, 4), 10);
        return { year, month, day };
    }
    /**
     * Método responsável por retornar a data com a hora definida para `00:00:00` caso `isMinDate` for igual a `true` ou `23:59:59`
     * caso `isMindate` seja igual a `false` .
     *
     * @param date Data no formato `Date` ou `yyyy-mm-ddThh:mm:ss+|-hh:mm`.
     * @param isMinDate Caso `true` aplica `00:00:00`, caso `false` aplica `23:59:59` a hora da data informada.
     */
    getDateForDateRange(date, isMinDate) {
        const lastHour = isMinDate ? [0, 0, 0] : [23, 59, 59];
        if (date instanceof Date) {
            const { year, month, day } = this.splitDate(date);
            const validDate = new Date(year, month, day, ...lastHour);
            this.setYearFrom0To100(validDate, year);
            return validDate;
        }
        else if (this.isValidIso(date)) {
            return this.convertIsoToDate(date, isMinDate, !isMinDate);
        }
    }
    /**
     * Retorna `true` caso o período seja válido, para isso a primeira data deve ser maior que a segunda data.
     * @param dateA primeira data
     * @param dateB segunda data
     */
    isDateRangeValid(dateA = '', dateB = '') {
        const dateASplitted = dateA.split('-').map(item => parseInt(item, 10));
        const dateBSplitted = dateB.split('-').map(item => parseInt(item, 10));
        for (let index = 0; index <= dateASplitted.length; index++) {
            if (dateASplitted[index] > dateBSplitted[index]) {
                return true;
            }
            else if (dateASplitted[index] < dateBSplitted[index]) {
                return false;
            }
        }
        return true;
    }
    /**
     * Método responsável por validar se uma data está no formato `yyyy-mm-ddThh:mm:ss+|-hh:mm` ou `yyyy-mm-dd`.
     *
     * @param stringDate Data.
     */
    isValidIso(stringDate) {
        return this.dateRegex.test(stringDate) || this.isoRegex.test(stringDate);
    }
    /**
     * Método responsável por corrigir a data caso a mesma esteja entre os anos 0 e 99.
     *
     * @param date Data.
     * @param year .
     */
    setYearFrom0To100(date, year) {
        if (year >= 0 && year < 100) {
            date.setFullYear(year);
        }
    }
    /**
     * Método responsável por ordenar duas datas.
     *
     * @param leftSide Primeira data a ser comparada.
     * @param rightSide Segunda data a ser comparada.
     * @param ascending Determina se será em ordem crescente ou decrescente.
     */
    sortDate(leftSide, rightSide, ascending) {
        return sortValues(this.validateDate(leftSide), this.validateDate(rightSide), ascending);
    }
    /**
     * Método responsável por retornar o dia , mês e ano de uma data informada.
     *
     * @param date Valor da data.
     */
    splitDate(date) {
        const year = date.getFullYear();
        const month = date.getMonth();
        const day = date.getDate();
        return { year, month, day };
    }
    /**
     * Método responsável por validar se uma data está entre a `minDate` e `maxDate`.
     *
     * @param date Data a ser validada.
     * @param minDate Data inicial.
     * @param maxDate Data final.
     */
    validateDateRange(date, minDate, maxDate) {
        if (minDate && maxDate) {
            return (date >= minDate && date <= maxDate);
        }
        else if (minDate && !maxDate) {
            return (date >= minDate);
        }
        else if (!minDate && maxDate) {
            return (date <= maxDate);
        }
        else {
            return true;
        }
    }
    /**
     * Método responsável por validar se a data foi informada nos padrões 'yyyy-mm-dd', 'yyyy-mm-ddThh:mm:ss+|-hh:mm' ou
     * 'Date' padrão do javascript.
     *
     * @param date Data que será validada.
     */
    validateDate(date) {
        const validDate = date instanceof Date ? this.convertDateToISO(date) : date;
        return this.isValidIso(validDate) ? validDate : undefined;
    }
};
PoDateService = tslib_1.__decorate([
    Injectable()
], PoDateService);
export { PoDateService };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG8tZGF0ZS5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHBvcnRpbmFyaS9wb3J0aW5hcmktdWkvIiwic291cmNlcyI6WyJsaWIvc2VydmljZXMvcG8tZGF0ZS9wby1kYXRlLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFM0MsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRTlDOzs7Ozs7R0FNRztBQUVILElBQWEsYUFBYSxHQUExQixNQUFhLGFBQWE7SUFSMUI7Ozs7OztPQU1HO0lBQ0g7UUFHbUIsY0FBUyxHQUFHLElBQUksTUFBTSxDQUFDLGtDQUFrQztZQUMxRSxvQkFBb0I7WUFDcEIsMkJBQTJCLENBQUMsQ0FBQztRQUVaLGFBQVEsR0FBRyxJQUFJLE1BQU0sQ0FBQyxrQ0FBa0M7WUFDekUsb0JBQW9CO1lBQ3BCLDBCQUEwQjtZQUMxQixrRUFBa0U7WUFDbEUsZ0RBQWdEO1lBQ2hELGtCQUFrQixDQUFDLENBQUM7SUF3TXRCLENBQUM7SUF0TUM7Ozs7OztPQU1HO0lBQ0gsZ0JBQWdCLENBQUMsVUFBa0IsRUFBRyxPQUFnQixFQUFFLE9BQWdCO1FBQ3RFLElBQUksVUFBVSxFQUFFO1lBQ2QsTUFBTSxFQUFFLElBQUksRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsQ0FBQztZQUU3RCxJQUFJLE9BQU8sRUFBRTtnQkFDWCxNQUFNLElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDckQsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDbkMsT0FBTyxJQUFJLENBQUM7YUFDYjtpQkFBTSxJQUFJLE9BQU8sRUFBRTtnQkFDbEIsTUFBTSxJQUFJLEdBQUcsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssR0FBRyxDQUFDLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7Z0JBQ3hELElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7Z0JBQ25DLE9BQU8sSUFBSSxDQUFDO2FBQ2I7aUJBQU07Z0JBQ0wsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQztnQkFDM0MsTUFBTSxRQUFRLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRSxHQUFHLEtBQUssQ0FBQztnQkFDeEQsT0FBTyxJQUFJLElBQUksQ0FBQyxXQUFXLEdBQUcsUUFBUSxDQUFDLENBQUM7YUFDekM7U0FDRjtJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsZ0JBQWdCLENBQUMsSUFBVTtRQUN6QixJQUFJLElBQUksRUFBRTtZQUNSLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztZQUNwQyxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQ3JDLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUN4RSxNQUFNLEtBQUssR0FBRyxRQUFRLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUM7WUFDeEQsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUN2QyxPQUFPLElBQUksR0FBRyxHQUFHLEdBQUcsS0FBSyxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUM7U0FDdkM7YUFBTTtZQUNMLE9BQU8sSUFBSSxDQUFDO1NBQ2I7SUFDSCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFVBQVUsQ0FBQyxJQUFZO1FBRXJCLElBQUksSUFBSSxHQUFHLEdBQUcsRUFBRTtZQUNkLE9BQU8sSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1NBQ3hCO1FBRUQsSUFBSSxJQUFJLEdBQUcsRUFBRSxJQUFJLElBQUksR0FBRyxJQUFJLEVBQUU7WUFDNUIsT0FBTyxJQUFJLElBQUksRUFBRSxDQUFDO1NBQ25CO1FBRUQsSUFBSSxJQUFJLEdBQUcsQ0FBQyxJQUFJLElBQUksR0FBRyxHQUFHLEVBQUU7WUFDMUIsT0FBTyxLQUFLLElBQUksRUFBRSxDQUFDO1NBQ3BCO1FBRUQsSUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJLElBQUksR0FBRyxFQUFFLEVBQUU7WUFDMUIsT0FBTyxNQUFNLElBQUksRUFBRSxDQUFDO1NBQ3JCO0lBQ0gsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxjQUFjLENBQUMsT0FBZTtRQUM1QixNQUFNLEdBQUcsR0FBRyxRQUFRLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDbkQsTUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3BELE1BQU0sSUFBSSxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUVuRCxPQUFPLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQztJQUM5QixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsbUJBQW1CLENBQUMsSUFBUyxFQUFFLFNBQWtCO1FBQy9DLE1BQU0sUUFBUSxHQUFHLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDdEQsSUFBSSxJQUFJLFlBQVksSUFBSSxFQUFFO1lBQ3hCLE1BQU0sRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDbEQsTUFBTSxTQUFTLEdBQUcsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsR0FBRyxRQUFRLENBQUMsQ0FBQztZQUMxRCxJQUFJLENBQUMsaUJBQWlCLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQ3hDLE9BQU8sU0FBUyxDQUFDO1NBQ2xCO2FBQU0sSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQ2hDLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksRUFBRSxTQUFTLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUMzRDtJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsZ0JBQWdCLENBQUMsUUFBZ0IsRUFBRSxFQUFFLFFBQWdCLEVBQUU7UUFDckQsTUFBTSxhQUFhLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDdkUsTUFBTSxhQUFhLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFFdkUsS0FBSyxJQUFJLEtBQUssR0FBRyxDQUFDLEVBQUUsS0FBSyxJQUFJLGFBQWEsQ0FBQyxNQUFNLEVBQUUsS0FBSyxFQUFFLEVBQUU7WUFFMUQsSUFBSSxhQUFhLENBQUMsS0FBSyxDQUFDLEdBQUcsYUFBYSxDQUFDLEtBQUssQ0FBQyxFQUFFO2dCQUMvQyxPQUFPLElBQUksQ0FBQzthQUNiO2lCQUFNLElBQUksYUFBYSxDQUFDLEtBQUssQ0FBQyxHQUFHLGFBQWEsQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDdEQsT0FBTyxLQUFLLENBQUM7YUFDZDtTQUVGO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFVBQVUsQ0FBQyxVQUFrQjtRQUMzQixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQzNFLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILGlCQUFpQixDQUFDLElBQVUsRUFBRSxJQUFZO1FBQ3hDLElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxJQUFJLEdBQUcsR0FBRyxFQUFHO1lBQzVCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7U0FDeEI7SUFDSCxDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsUUFBUSxDQUFDLFFBQXVCLEVBQUUsU0FBd0IsRUFBRSxTQUFrQjtRQUM1RSxPQUFPLFVBQVUsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxFQUFFLElBQUksQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDMUYsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxTQUFTLENBQUMsSUFBVTtRQUNsQixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7UUFDaEMsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQzlCLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUMzQixPQUFPLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQztJQUM5QixDQUFDO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsaUJBQWlCLENBQUMsSUFBVSxFQUFFLE9BQWEsRUFBRSxPQUFhO1FBQ3hELElBQUksT0FBTyxJQUFJLE9BQU8sRUFBRTtZQUN0QixPQUFPLENBQUMsSUFBSSxJQUFJLE9BQU8sSUFBSSxJQUFJLElBQUksT0FBTyxDQUFDLENBQUM7U0FDN0M7YUFBTSxJQUFJLE9BQU8sSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUM5QixPQUFPLENBQUMsSUFBSSxJQUFJLE9BQU8sQ0FBQyxDQUFDO1NBQzFCO2FBQU0sSUFBSSxDQUFDLE9BQU8sSUFBSSxPQUFPLEVBQUU7WUFDOUIsT0FBTyxDQUFDLElBQUksSUFBSSxPQUFPLENBQUMsQ0FBQztTQUMxQjthQUFNO1lBQ0wsT0FBTyxJQUFJLENBQUM7U0FDYjtJQUNILENBQUM7SUFFRDs7Ozs7T0FLRztJQUNLLFlBQVksQ0FBQyxJQUFtQjtRQUN0QyxNQUFNLFNBQVMsR0FBRyxJQUFJLFlBQVksSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztRQUU1RSxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0lBQzVELENBQUM7Q0FFRixDQUFBO0FBbk5ZLGFBQWE7SUFEekIsVUFBVSxFQUFFO0dBQ0EsYUFBYSxDQW1OekI7U0FuTlksYUFBYSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgc29ydFZhbHVlcyB9IGZyb20gJy4uLy4uL3V0aWxzL3V0aWwnO1xuXG4vKipcbiAqIEBkb2NzUHJpdmF0ZVxuICpcbiAqIEBkZXNjcmlwdGlvblxuICpcbiAqIFNlcnZpw6dvIHJlc3BvbnPDoXZlbCBwb3IgZ2VyZW5jaWFyIG8gdHJhdGFtZW50byBkb3MgZm9ybWF0b3MgZGUgZGF0YSBlIGhvcmEuXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBQb0RhdGVTZXJ2aWNlIHtcblxuICBwcml2YXRlIHJlYWRvbmx5IGRhdGVSZWdleCA9IG5ldyBSZWdFeHAoJ14oPzpbMC05XSlcXFxcZHsxfSg/OlswLTldKVxcXFxkezF9LScgK1xuICAnKD86MFsxLTldfDFbMC0yXSktJyArXG4gICcoPzowWzEtOV18WzEyXVxcXFxkfDNbMDFdKSQnKTtcblxuICBwcml2YXRlIHJlYWRvbmx5IGlzb1JlZ2V4ID0gbmV3IFJlZ0V4cCgnXig/OlswLTldKVxcXFxkezF9KD86WzAtOV0pXFxcXGR7MX0tJyArXG4gICcoPzowWzEtOV18MVswLTJdKS0nICtcbiAgJyg/OjBbMS05XXxbMTJdXFxcXGR8M1swMV0pJyArXG4gICdUKD86WzAxXVxcXFxkfDJbMC0zXSk6WzAtNV1cXFxcZDpbMC01XVxcXFxkKD86WnwtMFsxLTldfC0xXFxcXGR8LTJbMC0zXXwnICtcbiAgJy0wMDo/KD86MFsxLTldfFswLTVdXFxcXGQpfFxcXFwrWzAxXVxcXFxkfFxcXFwrMlswLTNdKScgK1xuICAnKD86fDo/WzAtNV1cXFxcZCkkJyk7XG5cbiAgLyoqXG4gICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciBjb252ZXJ0ZXIgZGF0YXMgZG8gZm9ybWF0byBgeXl5eS1tbS1kZFRoaDptbTpzcyt8LWhoOm1tYCBwYXJhIG8gZm9ybWF0byBgRGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRlU3RyaW5nIERhdGEgbm8gZm9ybWF0byBgeXl5eS1tbS1kZFRoaDptbTpzcyt8LWhoOm1tYC5cbiAgICogQHBhcmFtIG1pbkRhdGUgRGVmaW5pciBgdHJ1ZWAgY2FzbyBzZWphIGBtaW5EYXRlYC5cbiAgICogQHBhcmFtIG1heERhdGUgRGVmaW5pciBgdHJ1ZWAgY2FzbyBzZWphIGBtYXhEYXRlYC5cbiAgICovXG4gIGNvbnZlcnRJc29Ub0RhdGUoZGF0ZVN0cmluZzogc3RyaW5nICwgbWluRGF0ZTogYm9vbGVhbiwgbWF4RGF0ZTogYm9vbGVhbik6IERhdGUge1xuICAgIGlmIChkYXRlU3RyaW5nKSB7XG4gICAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXkgfSA9IHRoaXMuZ2V0RGF0ZUZyb21Jc28oZGF0ZVN0cmluZyk7XG5cbiAgICAgIGlmIChtaW5EYXRlKSB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuc2V0WWVhckZyb20wVG8xMDAoZGF0ZSwgeWVhcik7XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgfSBlbHNlIGlmIChtYXhEYXRlKSB7XG4gICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSwgMjMsIDU5LCA1OSk7XG4gICAgICAgIHRoaXMuc2V0WWVhckZyb20wVG8xMDAoZGF0ZSwgeWVhcik7XG4gICAgICAgIHJldHVybiBkYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWlsaXNlY29uZHMgPSBEYXRlLnBhcnNlKGRhdGVTdHJpbmcpO1xuICAgICAgICBjb25zdCB0aW1lem9uZSA9IG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwO1xuICAgICAgICByZXR1cm4gbmV3IERhdGUobWlsaXNlY29uZHMgKyB0aW1lem9uZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciBjb252ZXJ0ZXIgZGF0YSBkbyBmb3JtYXRvIGBEYXRlYCBwYXJhIG8gZm9ybWF0byBgeXl5eS1tbS1kZGAuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRlIERhdGEgbm8gZm9ybWF0byBgRGF0ZWAuXG4gICAqL1xuICBjb252ZXJ0RGF0ZVRvSVNPKGRhdGU6IERhdGUpIHtcbiAgICBpZiAoZGF0ZSkge1xuICAgICAgY29uc3QgZnVsbFllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgICBjb25zdCBnZXRNb250aCA9IGRhdGUuZ2V0TW9udGgoKSArIDE7XG4gICAgICBjb25zdCBkYXkgPSBkYXRlLmdldERhdGUoKSA8IDEwID8gJzAnICsgZGF0ZS5nZXREYXRlKCkgOiBkYXRlLmdldERhdGUoKTtcbiAgICAgIGNvbnN0IG1vbnRoID0gZ2V0TW9udGggPCAxMCA/ICcwJyArIGdldE1vbnRoIDogZ2V0TW9udGg7XG4gICAgICBjb25zdCB5ZWFyID0gdGhpcy5mb3JtYXRZZWFyKGZ1bGxZZWFyKTtcbiAgICAgIHJldHVybiB5ZWFyICsgJy0nICsgbW9udGggKyAnLScgKyBkYXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNw6l0b2RvIHJlc3BvbnPDoXZlbCBwb3IgYWRpY2lvbmFyIHplcm9zIGEgZXNxdWVyZGEgZG8gYW5vcyBlbSBmb3JtYXRvIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHllYXIgQW5vIGEgc2VyIHZhbGlkYWRvLlxuICAgKi9cbiAgZm9ybWF0WWVhcih5ZWFyOiBudW1iZXIpIHtcblxuICAgIGlmICh5ZWFyID4gOTk5KSB7XG4gICAgICByZXR1cm4geWVhci50b1N0cmluZygpO1xuICAgIH1cblxuICAgIGlmICh5ZWFyID4gOTkgJiYgeWVhciA8IDEwMDApIHtcbiAgICAgIHJldHVybiBgMCR7eWVhcn1gO1xuICAgIH1cblxuICAgIGlmICh5ZWFyID4gOSAmJiB5ZWFyIDwgMTAwKSB7XG4gICAgICByZXR1cm4gYDAwJHt5ZWFyfWA7XG4gICAgfVxuXG4gICAgaWYgKHllYXIgPj0gMCAmJiB5ZWFyIDwgMTApIHtcbiAgICAgIHJldHVybiBgMDAwJHt5ZWFyfWA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciByZXRvcm5hciBvIGRpYSwgbcOqcyBlIGFubyBzZXBhcmFkb3MgZW0gZm9ybWF0byBkZSBvYmpldG8uXG4gICAqXG4gICAqIEBwYXJhbSBpc29EYXRlIEFubyBlbSBmb3JtYXRvIHN0cmluZy5cbiAgICovXG4gIGdldERhdGVGcm9tSXNvKGlzb0RhdGU6IHN0cmluZyk6IHsgeWVhcjogbnVtYmVyLCBtb250aDogbnVtYmVyLCBkYXk6IG51bWJlciB9IHtcbiAgICBjb25zdCBkYXkgPSBwYXJzZUludChpc29EYXRlLnN1YnN0cmluZyg4LCAxMCksIDEwKTtcbiAgICBjb25zdCBtb250aCA9IHBhcnNlSW50KGlzb0RhdGUuc3Vic3RyaW5nKDUsIDcpLCAxMCk7XG4gICAgY29uc3QgeWVhciA9IHBhcnNlSW50KGlzb0RhdGUuc3Vic3RyaW5nKDAsIDQpLCAxMCk7XG5cbiAgICByZXR1cm4geyB5ZWFyLCBtb250aCwgZGF5IH07XG4gIH1cblxuICAvKipcbiAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIHJldG9ybmFyIGEgZGF0YSBjb20gYSBob3JhIGRlZmluaWRhIHBhcmEgYDAwOjAwOjAwYCBjYXNvIGBpc01pbkRhdGVgIGZvciBpZ3VhbCBhIGB0cnVlYCBvdSBgMjM6NTk6NTlgXG4gICAqIGNhc28gYGlzTWluZGF0ZWAgc2VqYSBpZ3VhbCBhIGBmYWxzZWAgLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0ZSBEYXRhIG5vIGZvcm1hdG8gYERhdGVgIG91IGB5eXl5LW1tLWRkVGhoOm1tOnNzK3wtaGg6bW1gLlxuICAgKiBAcGFyYW0gaXNNaW5EYXRlIENhc28gYHRydWVgIGFwbGljYSBgMDA6MDA6MDBgLCBjYXNvIGBmYWxzZWAgYXBsaWNhIGAyMzo1OTo1OWAgYSBob3JhIGRhIGRhdGEgaW5mb3JtYWRhLlxuICAgKi9cbiAgZ2V0RGF0ZUZvckRhdGVSYW5nZShkYXRlOiBhbnksIGlzTWluRGF0ZTogYm9vbGVhbikge1xuICAgIGNvbnN0IGxhc3RIb3VyID0gaXNNaW5EYXRlID8gWzAsIDAsIDBdIDogWzIzLCA1OSwgNTldO1xuICAgIGlmIChkYXRlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgY29uc3QgeyB5ZWFyLCBtb250aCwgZGF5IH0gPSB0aGlzLnNwbGl0RGF0ZShkYXRlKTtcbiAgICAgIGNvbnN0IHZhbGlkRGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoLCBkYXksIC4uLmxhc3RIb3VyKTtcbiAgICAgIHRoaXMuc2V0WWVhckZyb20wVG8xMDAodmFsaWREYXRlLCB5ZWFyKTtcbiAgICAgIHJldHVybiB2YWxpZERhdGU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzVmFsaWRJc28oZGF0ZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRJc29Ub0RhdGUoZGF0ZSwgaXNNaW5EYXRlLCAhaXNNaW5EYXRlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0b3JuYSBgdHJ1ZWAgY2FzbyBvIHBlcsOtb2RvIHNlamEgdsOhbGlkbywgcGFyYSBpc3NvIGEgcHJpbWVpcmEgZGF0YSBkZXZlIHNlciBtYWlvciBxdWUgYSBzZWd1bmRhIGRhdGEuXG4gICAqIEBwYXJhbSBkYXRlQSBwcmltZWlyYSBkYXRhXG4gICAqIEBwYXJhbSBkYXRlQiBzZWd1bmRhIGRhdGFcbiAgICovXG4gIGlzRGF0ZVJhbmdlVmFsaWQoZGF0ZUE6IHN0cmluZyA9ICcnLCBkYXRlQjogc3RyaW5nID0gJycpOiBib29sZWFuIHtcbiAgICBjb25zdCBkYXRlQVNwbGl0dGVkID0gZGF0ZUEuc3BsaXQoJy0nKS5tYXAoaXRlbSA9PiBwYXJzZUludChpdGVtLCAxMCkpO1xuICAgIGNvbnN0IGRhdGVCU3BsaXR0ZWQgPSBkYXRlQi5zcGxpdCgnLScpLm1hcChpdGVtID0+IHBhcnNlSW50KGl0ZW0sIDEwKSk7XG5cbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDw9IGRhdGVBU3BsaXR0ZWQubGVuZ3RoOyBpbmRleCsrKSB7XG5cbiAgICAgIGlmIChkYXRlQVNwbGl0dGVkW2luZGV4XSA+IGRhdGVCU3BsaXR0ZWRbaW5kZXhdKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkYXRlQVNwbGl0dGVkW2luZGV4XSA8IGRhdGVCU3BsaXR0ZWRbaW5kZXhdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciB2YWxpZGFyIHNlIHVtYSBkYXRhIGVzdMOhIG5vIGZvcm1hdG8gYHl5eXktbW0tZGRUaGg6bW06c3MrfC1oaDptbWAgb3UgYHl5eXktbW0tZGRgLlxuICAgKlxuICAgKiBAcGFyYW0gc3RyaW5nRGF0ZSBEYXRhLlxuICAgKi9cbiAgaXNWYWxpZElzbyhzdHJpbmdEYXRlOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5kYXRlUmVnZXgudGVzdChzdHJpbmdEYXRlKSB8fCB0aGlzLmlzb1JlZ2V4LnRlc3Qoc3RyaW5nRGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIGNvcnJpZ2lyIGEgZGF0YSBjYXNvIGEgbWVzbWEgZXN0ZWphIGVudHJlIG9zIGFub3MgMCBlIDk5LlxuICAgKlxuICAgKiBAcGFyYW0gZGF0ZSBEYXRhLlxuICAgKiBAcGFyYW0geWVhciAuXG4gICAqL1xuICBzZXRZZWFyRnJvbTBUbzEwMChkYXRlOiBEYXRlLCB5ZWFyOiBudW1iZXIpIHtcbiAgICBpZiAoeWVhciA+PSAwICYmIHllYXIgPCAxMDAgKSB7XG4gICAgICBkYXRlLnNldEZ1bGxZZWFyKHllYXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNw6l0b2RvIHJlc3BvbnPDoXZlbCBwb3Igb3JkZW5hciBkdWFzIGRhdGFzLlxuICAgKlxuICAgKiBAcGFyYW0gbGVmdFNpZGUgUHJpbWVpcmEgZGF0YSBhIHNlciBjb21wYXJhZGEuXG4gICAqIEBwYXJhbSByaWdodFNpZGUgU2VndW5kYSBkYXRhIGEgc2VyIGNvbXBhcmFkYS5cbiAgICogQHBhcmFtIGFzY2VuZGluZyBEZXRlcm1pbmEgc2Ugc2Vyw6EgZW0gb3JkZW0gY3Jlc2NlbnRlIG91IGRlY3Jlc2NlbnRlLlxuICAgKi9cbiAgc29ydERhdGUobGVmdFNpZGU6IHN0cmluZyB8IERhdGUsIHJpZ2h0U2lkZTogc3RyaW5nIHwgRGF0ZSwgYXNjZW5kaW5nOiBib29sZWFuKTogbnVtYmVyIHtcbiAgICByZXR1cm4gc29ydFZhbHVlcyh0aGlzLnZhbGlkYXRlRGF0ZShsZWZ0U2lkZSksIHRoaXMudmFsaWRhdGVEYXRlKHJpZ2h0U2lkZSksIGFzY2VuZGluZyk7XG4gIH1cblxuICAvKipcbiAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIHJldG9ybmFyIG8gZGlhICwgbcOqcyBlIGFubyBkZSB1bWEgZGF0YSBpbmZvcm1hZGEuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRlIFZhbG9yIGRhIGRhdGEuXG4gICAqL1xuICBzcGxpdERhdGUoZGF0ZTogRGF0ZSkge1xuICAgIGNvbnN0IHllYXIgPSBkYXRlLmdldEZ1bGxZZWFyKCk7XG4gICAgY29uc3QgbW9udGggPSBkYXRlLmdldE1vbnRoKCk7XG4gICAgY29uc3QgZGF5ID0gZGF0ZS5nZXREYXRlKCk7XG4gICAgcmV0dXJuIHsgeWVhciwgbW9udGgsIGRheSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciB2YWxpZGFyIHNlIHVtYSBkYXRhIGVzdMOhIGVudHJlIGEgYG1pbkRhdGVgIGUgYG1heERhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0gZGF0ZSBEYXRhIGEgc2VyIHZhbGlkYWRhLlxuICAgKiBAcGFyYW0gbWluRGF0ZSBEYXRhIGluaWNpYWwuXG4gICAqIEBwYXJhbSBtYXhEYXRlIERhdGEgZmluYWwuXG4gICAqL1xuICB2YWxpZGF0ZURhdGVSYW5nZShkYXRlOiBEYXRlLCBtaW5EYXRlOiBEYXRlLCBtYXhEYXRlOiBEYXRlKSB7XG4gICAgaWYgKG1pbkRhdGUgJiYgbWF4RGF0ZSkge1xuICAgICAgcmV0dXJuIChkYXRlID49IG1pbkRhdGUgJiYgZGF0ZSA8PSBtYXhEYXRlKTtcbiAgICB9IGVsc2UgaWYgKG1pbkRhdGUgJiYgIW1heERhdGUpIHtcbiAgICAgIHJldHVybiAoZGF0ZSA+PSBtaW5EYXRlKTtcbiAgICB9IGVsc2UgaWYgKCFtaW5EYXRlICYmIG1heERhdGUpIHtcbiAgICAgIHJldHVybiAoZGF0ZSA8PSBtYXhEYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciB2YWxpZGFyIHNlIGEgZGF0YSBmb2kgaW5mb3JtYWRhIG5vcyBwYWRyw7VlcyAneXl5eS1tbS1kZCcsICd5eXl5LW1tLWRkVGhoOm1tOnNzK3wtaGg6bW0nIG91XG4gICAqICdEYXRlJyBwYWRyw6NvIGRvIGphdmFzY3JpcHQuXG4gICAqXG4gICAqIEBwYXJhbSBkYXRlIERhdGEgcXVlIHNlcsOhIHZhbGlkYWRhLlxuICAgKi9cbiAgcHJpdmF0ZSB2YWxpZGF0ZURhdGUoZGF0ZTogc3RyaW5nIHwgRGF0ZSkge1xuICAgIGNvbnN0IHZhbGlkRGF0ZSA9IGRhdGUgaW5zdGFuY2VvZiBEYXRlID8gdGhpcy5jb252ZXJ0RGF0ZVRvSVNPKGRhdGUpIDogZGF0ZTtcblxuICAgIHJldHVybiB0aGlzLmlzVmFsaWRJc28odmFsaWREYXRlKSA/IHZhbGlkRGF0ZSA6IHVuZGVmaW5lZDtcbiAgfVxuXG59XG4iXX0=