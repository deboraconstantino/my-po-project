/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
// Idiomas suportados pelas páginas
/** @type {?} */
export var poLocales = ['pt', 'en', 'es', 'ru'];
// Idioma padrão
/** @type {?} */
export var poLocaleDefault = 'pt';
/**
 * @deprecated
 * Utilize o método `getShortBrowserLanguage`.
 *
 * \@description
 * Retorna idioma do browser ou o idioma padrão.
 * @return {?}
 */
export function browserLanguage() {
    return getShortBrowserLanguage();
}
/**
 * Retorna o idioma atual do navegador
 * @return {?}
 */
export function getBrowserLanguage() {
    // navigator.userLanguage is the value for IE10
    return navigator.language || navigator['userLanguage'];
}
/**
 * Retorna o idioma do navegador, com somente as duas primeiras letras. Por exemplo: "pt" ou "es".
 *
 * Caso o valor retornado pelo navegador não estiver dentro dos idiomas suportados pelo PO,
 * será retornado a linguagem padrão (poLocaleDefault).
 * @return {?}
 */
export function getShortBrowserLanguage() {
    /** @type {?} */
    var language = (getBrowserLanguage() || poLocaleDefault).toLowerCase().substring(0, 2);
    if (!poLocales.includes(language)) {
        return poLocaleDefault;
    }
    return language;
}
/**
 * @param {?} val
 * @return {?}
 */
export function convertToBoolean(val) {
    if (typeof val === 'string') {
        val = val.toLowerCase().trim();
        return (val === 'true' || val === 'on' || val === '');
    }
    if (typeof val === 'number') {
        return val === 1;
    }
    return !!val;
}
/**
 * @param {?} value
 * @param {?=} valueDefault
 * @return {?}
 */
export function convertToInt(value, valueDefault) {
    /** @type {?} */
    var validNumber = parseInt(value, 10);
    /** @type {?} */
    var validDefaultValue = parseInt(valueDefault, 10);
    /** @type {?} */
    var defaultValue = validDefaultValue || validDefaultValue === 0 ? validDefaultValue : undefined;
    return validNumber || validNumber === 0 ? validNumber : defaultValue;
}
/**
 * @param {?} object
 * @param {?} type
 * @return {?}
 */
export function isTypeof(object, type) {
    return typeof object === type;
}
/**
 *
 * @param {?} fn Função que será executada dentro do contexto. Podendo ser o nome da função
 * ou a referência da mesma.
 *
 * @param {?} context Contexto do qual a função será executada.
 * @param {?=} param
 * @return {?}
 */
export function callFunction(fn, context, param) {
    if (isTypeof(fn, 'function')) {
        fn.call(context, param);
    }
    else {
        context[fn](param);
    }
}
/**
 * @param {?} value
 * @param {?} start
 * @param {?} end
 * @return {?}
 */
export function convertIsoToDate(value, start, end) {
    if (value) {
        /** @type {?} */
        var day = parseInt(value.substring(8, 10), 10);
        /** @type {?} */
        var month = parseInt(value.substring(5, 7), 10);
        /** @type {?} */
        var year = parseInt(value.substring(0, 4), 10);
        if (start) {
            /** @type {?} */
            var date = new Date(year, month - 1, day, 0, 0, 0);
            setYearFrom0To100(date, year);
            return date;
        }
        else if (end) {
            /** @type {?} */
            var date = new Date(year, month - 1, day, 23, 59, 59);
            setYearFrom0To100(date, year);
            return date;
        }
        else {
            /** @type {?} */
            var milliseconds = Date.parse(value);
            /** @type {?} */
            var timezone = new Date().getTimezoneOffset() * 60000;
            return new Date(milliseconds + timezone);
        }
    }
}
/**
 * @param {?} date
 * @param {?=} time
 * @return {?}
 */
export function convertDateToISOExtended(date, time) {
    if (date) {
        /** @type {?} */
        var getMonth = date.getMonth() + 1;
        /** @type {?} */
        var day = date.getDate() < 10 ? '0' + date.getDate() : date.getDate();
        /** @type {?} */
        var month = getMonth < 10 ? '0' + getMonth : getMonth;
        /** @type {?} */
        var year = formatYear(date.getFullYear());
        /** @type {?} */
        var dateString = date.toString();
        if (time) {
            return year + '-' + month + '-' + day + time;
        }
        else {
            return year + '-' + month + '-' + day + 'T' + dateString.substring(16, 24) +
                dateString.substring(28, 31) + ':' + dateString.substring(31, 33);
        }
    }
    else {
        return null;
    }
}
/**
 * Transforma o ano em uma string no formato yyyy e caso o ano seja menor que 1000 preenche com zeros a esquerda.
 * @param {?} year Ano
 * @return {?}
 */
export function formatYear(year) {
    if (year >= 1000) {
        return year.toString();
    }
    if (year > 99 && year < 1000) {
        return "0" + year;
    }
    if (year > 9 && year < 100) {
        return "00" + year;
    }
    if (year >= 0 && year < 10) {
        return "000" + year;
    }
}
/**
 * @param {?} value
 * @param {?} comparedValue
 * @return {?}
 */
export function isEquals(value, comparedValue) {
    return JSON.stringify(value) === JSON.stringify(comparedValue);
}
/**
 * Caso o ano original da data seja entre 0 e 100 atribui esse valor ao ano, pois o `new Date` do javascript transforma o ano para 190X.
 * @param {?} date Data
 * @param {?} year Ano original
 * @return {?}
 */
export function setYearFrom0To100(date, year) {
    if (year >= 0 && year < 100) {
        date.setFullYear(year);
    }
}
/**
 * @param {?} options
 * @param {?} property
 * @return {?}
 */
export function sortOptionsByProperty(options, property) {
    options.sort((/**
     * @param {?} optionA
     * @param {?} optionB
     * @return {?}
     */
    function (optionA, optionB) {
        optionA = optionA[property].toString().toLowerCase();
        optionB = optionB[property].toString().toLowerCase();
        if (optionA < optionB) {
            return -1;
        }
        if (optionA > optionB) {
            return 1;
        }
        return 0;
    }));
}
/**
 * @param {?} list
 * @return {?}
 */
export function removeDuplicatedOptions(list) {
    var _loop_1 = function (i) {
        if (i === 0) {
            return out_i_1 = i, "continue";
        }
        if (list.findIndex((/**
         * @param {?} op
         * @return {?}
         */
        function (op) { return op.value === list[i].value; })) !== i) {
            list.splice(i, 1);
            i--;
        }
        out_i_1 = i;
    };
    var out_i_1;
    for (var i = 0; i < list.length; i++) {
        _loop_1(i);
        i = out_i_1;
    }
}
/**
 * @param {?} list
 * @return {?}
 */
export function removeUndefinedAndNullOptions(list) {
    for (var i = 0; i < list.length; i++) {
        if (list[i].value === undefined || list[i].value === null) {
            list.splice(i, 1);
            i--;
        }
    }
}
/**
 * @param {?} value
 * @return {?}
 */
export function validValue(value) {
    return (value !== null && value !== undefined && value !== '') || value === false;
}
/**
 * @param {?} url
 * @return {?}
 */
export function isExternalLink(url) {
    return url ? url.startsWith('http') : false;
}
/**
 * @param {?} url
 * @return {?}
 */
export function openExternalLink(url) {
    window.open(url, '_blank');
}
/**
 * @param {?} link
 * @return {?}
 */
export function getFormattedLink(link) {
    /** @type {?} */
    var formattedLink = '';
    // Retira todos os pontos no começo da URL.
    if (link) {
        formattedLink = link.replace(/^(\.)+/g, '');
    }
    // Verifica se foi utilizado uma rota que não comece com barra.
    if (!formattedLink.startsWith('/')) {
        formattedLink = '/'.concat(formattedLink);
    }
    return formattedLink;
}
/**
 * Método responsável por ordenar dois valores.
 *
 * @param {?} leftSide Primeiro valor a ser comparado.
 * @param {?} rightSide Segundo valor a ser comparado.
 * @param {?=} ascending Determina se será em ordem ascendente ou descendente.
 * @return {?}
 */
export function sortValues(leftSide, rightSide, ascending) {
    if (ascending === void 0) { ascending = true; }
    if (ascending) {
        if (leftSide < rightSide) {
            return -1;
        }
        else if (leftSide > rightSide) {
            return 1;
        }
    }
    else if (ascending === false) {
        if (leftSide < rightSide) {
            return 1;
        }
        else if (leftSide > rightSide) {
            return -1;
        }
    }
    return 0;
}
/**
 * @param {?} date
 * @param {?} dateStart
 * @param {?} dateEnd
 * @return {?}
 */
export function validateDateRange(date, dateStart, dateEnd) {
    if (dateStart && dateEnd) {
        return (date >= dateStart && date <= dateEnd);
    }
    else if (dateStart && !dateEnd) {
        return (date >= dateStart);
    }
    else if (!dateStart && dateEnd) {
        return (date <= dateEnd);
    }
    else {
        return true;
    }
}
/**
 * @param {?} text
 * @return {?}
 */
export function capitalizeFirstLetter(text) {
    return "" + text.charAt(0).toUpperCase() + text.slice(1);
}
/**
 * Mapeia um novo array apenas com as propriedades definidas pelo desenvolvedor baseado em um array de
 * origem.
 *
 * Exemplo:
 *
 * ```
 * const people = [
 *  { id: 1, name: 'Fulano', birthdate: '1980-11-01', genre: 'Male', city: 'São Paulo', dependents: 2 },
 *  { id: 2, name: 'Beltrano', birthdate: '1997-01-21', genre: 'Female', city: 'Joinville', dependents: 0 },
 *  { id: 3, name: 'Siclano', birthdate: '1995-07-15', genre: 'Male', city: 'Joinville', dependents: 0 }
 * ];
 *
 * const properties = ['id', 'name'];
 *
 * const idAndName = mapArrayByProperties(people, properties);
 *
 * console.log(idAndName); // [{ id: 1, name: 'Fulano' }, { id: 2, name: 'Beltrano' }, { id: 3, name: 'Siclano' }]
 * ```
 *
 * Um outro uso para o método é "parear" todos os objetos do array com as mesmas propriedades.
 *
 * ```
 * const customers = [
 *  { id: 1, name: 'Fulano', city: 'São Paulo', dependents: 2 }, // sem genre
 *  { id: 2, name: 'Beltrano', genre: 'Female', city: 'Joinville' }, // sem dependents
 *  { id: 3, name: 'Siclano', genre: 'Male', city: 'Joinville', dependents: 0 }
 * ];
 * const properties = ['id', 'name', 'city', 'genre', 'dependents'];
 *
 * const pattern = mapArrayByProperties(customers, properties);
 * console.log(pattern);
 *
 * // [
 * //   { id: 1, name: 'Fulano', city: 'São Paulo', genre: undefined, dependents: 2 },
 * //   { id: 2, name: 'Beltrano', city: 'Joinville', genre: 'Female', dependents: undefined },
 * //   { id: 3, name: 'Siclano', city: 'Joinville', genre: 'Male', dependents: 0 }
 * // ]
 * ```
 *
 * @param {?=} items {Array<any>} Array de items original.
 * @param {?=} properties {Array<string>} Array de string com a lista de propriedades que devem ser retornadas.
 *
 * @return {?} Array<any>
 */
export function mapArrayByProperties(items, properties) {
    if (items === void 0) { items = []; }
    if (properties === void 0) { properties = []; }
    return items.map((/**
     * @param {?} item
     * @return {?}
     */
    function (item) { return mapObjectByProperties(item, properties); }));
}
/**
 * Mapeia um novo objeto apenas com as propriedades definidas pelo desenvolvedor.
 *
 * Exemplo:
 *
 * ```
 * const person = { id: 1, name: 'Fulano', birthdate: '1980-11-01', genre: 'Male', city: 'São Paulo', dependents: 2 };
 *
 * const properties = ['id', 'name'];
 *
 * const idAndName = mapObjectByProperties(person, properties);
 *
 * console.log(idAndName); // { id: 1, name: 'Fulano' }
 * ```
 *
 * @param {?=} object {Array<any>} Array de items original.
 * @param {?=} properties {Array<string>} Array de string com a lista de propriedades que devem ser retornadas.
 *
 * @return {?} Array<any>
 */
export function mapObjectByProperties(object, properties) {
    if (object === void 0) { object = {}; }
    if (properties === void 0) { properties = []; }
    /** @type {?} */
    var getSelectedProperties = (/**
     * @param {?} selectedProperties
     * @param {?} property
     * @return {?}
     */
    function (selectedProperties, property) {
        var _a;
        return (tslib_1.__assign({}, selectedProperties, (_a = {}, _a[property] = object[property], _a)));
    });
    return properties.reduce(getSelectedProperties, {});
}
/**
 * Retorna os valores de um objeto dentro de um array.
 *
 * > Simula o Object.values(obj), o mesmo deve ser removido assim que a versão typescrit for atualizada.
 *
 * @param {?=} object Objeto de onde será pego os valores.
 * @return {?}
 */
export function valuesFromObject(object) {
    if (object === void 0) { object = {}; }
    return Object.keys(object).map((/**
     * @param {?} property
     * @return {?}
     */
    function (property) { return object[property]; }));
}
/**
 * adiciona 0 no tempo informado, caso menor q 10
 *
 * @param {?} time
 * @return {?}
 */
export function addZero(time) {
    if (!time) {
        return '00';
    }
    if (time < 10) {
        return "0" + time;
    }
    return time;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bwb3J0aW5hcmkvcG9ydGluYXJpLXRlbXBsYXRlcy8iLCJzb3VyY2VzIjpbImxpYi91dGlscy91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFDQSxNQUFNLEtBQU8sU0FBUyxHQUFHLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDOzs7QUFFakQsTUFBTSxLQUFPLGVBQWUsR0FBRyxJQUFJOzs7Ozs7Ozs7QUFTbkMsTUFBTSxVQUFVLGVBQWU7SUFDN0IsT0FBTyx1QkFBdUIsRUFBRSxDQUFDO0FBQ25DLENBQUM7Ozs7O0FBS0QsTUFBTSxVQUFVLGtCQUFrQjtJQUNoQywrQ0FBK0M7SUFDL0MsT0FBTyxTQUFTLENBQUMsUUFBUSxJQUFJLFNBQVMsQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUN6RCxDQUFDOzs7Ozs7OztBQVFELE1BQU0sVUFBVSx1QkFBdUI7O1FBQy9CLFFBQVEsR0FBRyxDQUFDLGtCQUFrQixFQUFFLElBQUksZUFBZSxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7SUFFeEYsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEVBQUU7UUFDakMsT0FBTyxlQUFlLENBQUM7S0FDeEI7SUFFRCxPQUFPLFFBQVEsQ0FBQztBQUNsQixDQUFDOzs7OztBQUVELE1BQU0sVUFBVSxnQkFBZ0IsQ0FBQyxHQUFRO0lBQ3ZDLElBQUksT0FBTyxHQUFHLEtBQUssUUFBUSxFQUFFO1FBQzNCLEdBQUcsR0FBRyxHQUFHLENBQUMsV0FBVyxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDL0IsT0FBTyxDQUFDLEdBQUcsS0FBSyxNQUFNLElBQUksR0FBRyxLQUFLLElBQUksSUFBSSxHQUFHLEtBQUssRUFBRSxDQUFDLENBQUM7S0FDdkQ7SUFFRCxJQUFJLE9BQU8sR0FBRyxLQUFLLFFB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QUFBO0lBRXpILE9BQU8sVUFBVSxDQUFDLE1BQU0sQ0FBQyxxQkFBcUIsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUN0RCxDQUFDOzs7Ozs7Ozs7QUFTRCxNQUFNLFVBQVUsZ0JBQWdCLENBQUMsTUFBZ0I7SUFBaEIsdUJBQUEsRUFBQSxXQUFnQjtJQUMvQyxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRzs7OztJQUFDLFVBQUEsUUFBUSxJQUFJLE9BQUEsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUFoQixDQUFnQixFQUFDLENBQUM7QUFDL0QsQ0FBQzs7Ozs7OztBQU9ELE1BQU0sVUFBVSxPQUFPLENBQUMsSUFBWTtJQUNsQyxJQUFJLENBQUMsSUFBSSxFQUFFO1FBQ1QsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUVELElBQUksSUFBSSxHQUFHLEVBQUUsRUFBRTtRQUNiLE9BQU8sTUFBSSxJQUFNLENBQUM7S0FDbkI7SUFFRCxPQUFPLElBQUksQ0FBQztBQUNkLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJZGlvbWFzIHN1cG9ydGFkb3MgcGVsYXMgcMOhZ2luYXNcclxuZXhwb3J0IGNvbnN0IHBvTG9jYWxlcyA9IFsncHQnLCAnZW4nLCAnZXMnLCAncnUnXTtcclxuLy8gSWRpb21hIHBhZHLDo29cclxuZXhwb3J0IGNvbnN0IHBvTG9jYWxlRGVmYXVsdCA9ICdwdCc7XHJcblxyXG4vKipcclxuICogQGRlcHJlY2F0ZWRcclxuICogVXRpbGl6ZSBvIG3DqXRvZG8gYGdldFNob3J0QnJvd3Nlckxhbmd1YWdlYC5cclxuICpcclxuICogQGRlc2NyaXB0aW9uXHJcbiAqIFJldG9ybmEgaWRpb21hIGRvIGJyb3dzZXIgb3UgbyBpZGlvbWEgcGFkcsOjby5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBicm93c2VyTGFuZ3VhZ2UoKSB7XHJcbiAgcmV0dXJuIGdldFNob3J0QnJvd3Nlckxhbmd1YWdlKCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXRvcm5hIG8gaWRpb21hIGF0dWFsIGRvIG5hdmVnYWRvclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEJyb3dzZXJMYW5ndWFnZSgpOiBzdHJpbmcge1xyXG4gIC8vIG5hdmlnYXRvci51c2VyTGFuZ3VhZ2UgaXMgdGhlIHZhbHVlIGZvciBJRTEwXHJcbiAgcmV0dXJuIG5hdmlnYXRvci5sYW5ndWFnZSB8fCBuYXZpZ2F0b3JbJ3VzZXJMYW5ndWFnZSddO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0b3JuYSBvIGlkaW9tYSBkbyBuYXZlZ2Fkb3IsIGNvbSBzb21lbnRlIGFzIGR1YXMgcHJpbWVpcmFzIGxldHJhcy4gUG9yIGV4ZW1wbG86IFwicHRcIiBvdSBcImVzXCIuXHJcbiAqXHJcbiAqIENhc28gbyB2YWxvciByZXRvcm5hZG8gcGVsbyBuYXZlZ2Fkb3IgbsOjbyBlc3RpdmVyIGRlbnRybyBkb3MgaWRpb21hcyBzdXBvcnRhZG9zIHBlbG8gUE8sXHJcbiAqIHNlcsOhIHJldG9ybmFkbyBhIGxpbmd1YWdlbSBwYWRyw6NvIChwb0xvY2FsZURlZmF1bHQpLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNob3J0QnJvd3Nlckxhbmd1YWdlKCk6IHN0cmluZyB7XHJcbiAgY29uc3QgbGFuZ3VhZ2UgPSAoZ2V0QnJvd3Nlckxhbmd1YWdlKCkgfHwgcG9Mb2NhbGVEZWZhdWx0KS50b0xvd2VyQ2FzZSgpLnN1YnN0cmluZygwLCAyKTtcclxuXHJcbiAgaWYgKCFwb0xvY2FsZXMuaW5jbHVkZXMobGFuZ3VhZ2UpKSB7XHJcbiAgICByZXR1cm4gcG9Mb2NhbGVEZWZhdWx0O1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGxhbmd1YWdlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFRvQm9vbGVhbih2YWw6IGFueSk6IGJvb2xlYW4ge1xyXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xyXG4gICAgdmFsID0gdmFsLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xyXG4gICAgcmV0dXJuICh2YWwgPT09ICd0cnVlJyB8fCB2YWwgPT09ICdvbicgfHwgdmFsID09PSAnJyk7XHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcclxuICAgIHJldHVybiB2YWwgPT09IDE7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gISF2YWw7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9JbnQodmFsdWU6IGFueSwgdmFsdWVEZWZhdWx0PzogYW55KTogbnVtYmVyIHtcclxuICBjb25zdCB2YWxpZE51bWJlciA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XHJcbiAgY29uc3QgdmFsaWREZWZhdWx0VmFsdWUgPSBwYXJzZUludCh2YWx1ZURlZmF1bHQsIDEwKTtcclxuICBjb25zdCBkZWZhdWx0VmFsdWUgPSB2YWxpZERlZmF1bHRWYWx1ZSB8fCB2YWxpZERlZmF1bHRWYWx1ZSA9PT0gMCA/IHZhbGlkRGVmYXVsdFZhbHVlIDogdW5kZWZpbmVkO1xyXG5cclxuICByZXR1cm4gdmFsaWROdW1iZXIgfHwgdmFsaWROdW1iZXIgPT09IDAgPyB2YWxpZE51bWJlciA6IGRlZmF1bHRWYWx1ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGlzVHlwZW9mKG9iamVjdDogYW55LCB0eXBlOiBhbnkpIHtcclxuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gdHlwZTtcclxufVxyXG5cclxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSBmbiBGdW7Dp8OjbyBxdWUgc2Vyw6EgZXhlY3V0YWRhIGRlbnRybyBkbyBjb250ZXh0by4gUG9kZW5kbyBzZXIgbyBub21lIGRhIGZ1bsOnw6NvXHJcbiAqIG91IGEgcmVmZXLDqm5jaWEgZGEgbWVzbWEuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb250ZXh0IENvbnRleHRvIGRvIHF1YWwgYSBmdW7Dp8OjbyBzZXLDoSBleGVjdXRhZGEuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY2FsbEZ1bmN0aW9uKGZuOiBhbnksIGNvbnRleHQ6IGFueSwgcGFyYW0/KTogdm9pZCB7XHJcbiAgaWYgKGlzVHlwZW9mKGZuLCAnZnVuY3Rpb24nKSkge1xyXG4gICAgZm4uY2FsbChjb250ZXh0LCBwYXJhbSk7XHJcbiAgfSBlbHNlIHtcclxuICAgIGNvbnRleHRbZm5dKHBhcmFtKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0SXNvVG9EYXRlKHZhbHVlOiBzdHJpbmcgLCBzdGFydDogYm9vbGVhbiwgZW5kOiBib29sZWFuKSB7XHJcbiAgaWYgKHZhbHVlKSB7XHJcbiAgICBjb25zdCBkYXkgPSBwYXJzZUludCh2YWx1ZS5zdWJzdHJpbmcoOCwgMTApLCAxMCk7XHJcbiAgICBjb25zdCBtb250aCA9IHBhcnNlSW50KHZhbHVlLnN1YnN0cmluZyg1LCA3KSwgMTApO1xyXG4gICAgY29uc3QgeWVhciA9IHBhcnNlSW50KHZhbHVlLnN1YnN0cmluZygwLCA0KSwgMTApO1xyXG4gICAgaWYgKHN0YXJ0KSB7XHJcbiAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSh5ZWFyLCBtb250aCAtIDEsIGRheSwgMCwgMCwgMCk7XHJcblxyXG4gICAgICBzZXRZZWFyRnJvbTBUbzEwMChkYXRlLCB5ZWFyKTtcclxuXHJcbiAgICAgIHJldHVybiBkYXRlO1xyXG4gICAgfSBlbHNlIGlmIChlbmQpIHtcclxuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoIC0gMSwgZGF5LCAyMywgNTksIDU5KTtcclxuXHJcbiAgICAgIHNldFllYXJGcm9tMFRvMTAwKGRhdGUsIHllYXIpO1xyXG5cclxuICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCBtaWxsaXNlY29uZHMgPSBEYXRlLnBhcnNlKHZhbHVlKTtcclxuICAgICAgY29uc3QgdGltZXpvbmUgPSBuZXcgRGF0ZSgpLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDAwMDtcclxuICAgICAgcmV0dXJuIG5ldyBEYXRlKG1pbGxpc2Vjb25kcyArIHRpbWV6b25lKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0RGF0ZVRvSVNPRXh0ZW5kZWQoZGF0ZTogRGF0ZSwgdGltZT86IHN0cmluZykge1xyXG4gIGlmIChkYXRlKSB7XHJcblxyXG4gICAgY29uc3QgZ2V0TW9udGggPSBkYXRlLmdldE1vbnRoKCkgKyAxO1xyXG4gICAgY29uc3QgZGF5ID0gZGF0ZS5nZXREYXRlKCkgPCAxMCA/ICcwJyArIGRhdGUuZ2V0RGF0ZSgpIDogZGF0ZS5nZXREYXRlKCk7XHJcbiAgICBjb25zdCBtb250aCA9IGdldE1vbnRoIDwgMTAgPyAnMCcgKyBnZXRNb250aCA6IGdldE1vbnRoO1xyXG4gICAgY29uc3QgeWVhciA9IGZvcm1hdFllYXIoZGF0ZS5nZXRGdWxsWWVhcigpKTtcclxuXHJcbiAgICBjb25zdCBkYXRlU3RyaW5nID0gZGF0ZS50b1N0cmluZygpO1xyXG5cclxuICAgIGlmICh0aW1lKSB7XHJcbiAgICAgIHJldHVybiB5ZWFyICsgJy0nICsgbW9udGggKyAnLScgKyBkYXkgKyB0aW1lO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcmV0dXJuIHllYXIgKyAnLScgKyBtb250aCArICctJyArIGRheSArICdUJyArIGRhdGVTdHJpbmcuc3Vic3RyaW5nKDE2LCAyNCkgK1xyXG4gICAgICAgICAgZGF0ZVN0cmluZy5zdWJzdHJpbmcoMjgsIDMxKSArICc6JyArIGRhdGVTdHJpbmcuc3Vic3RyaW5nKDMxLCAzMyk7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFRyYW5zZm9ybWEgbyBhbm8gZW0gdW1hIHN0cmluZyBubyBmb3JtYXRvIHl5eXkgZSBjYXNvIG8gYW5vIHNlamEgbWVub3IgcXVlIDEwMDAgcHJlZW5jaGUgY29tIHplcm9zIGEgZXNxdWVyZGEuXHJcbiAqIEBwYXJhbSB5ZWFyIEFub1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdFllYXIoeWVhcjogbnVtYmVyKSB7XHJcblxyXG4gIGlmICh5ZWFyID49IDEwMDApIHtcclxuICAgIHJldHVybiB5ZWFyLnRvU3RyaW5nKCk7XHJcbiAgfVxyXG5cclxuICBpZiAoeWVhciA+IDk5ICYmIHllYXIgPCAxMDAwKSB7XHJcbiAgICByZXR1cm4gYDAke3llYXJ9YDtcclxuICB9XHJcblxyXG4gIGlmICh5ZWFyID4gOSAmJiB5ZWFyIDwgMTAwKSB7XHJcbiAgICByZXR1cm4gYDAwJHt5ZWFyfWA7XHJcbiAgfVxyXG5cclxuICBpZiAoeWVhciA+PSAwICYmIHllYXIgPCAxMCkge1xyXG4gICAgcmV0dXJuIGAwMDAke3llYXJ9YDtcclxuICB9XHJcblxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNFcXVhbHModmFsdWUsIGNvbXBhcmVkVmFsdWUpIHtcclxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpID09PSBKU09OLnN0cmluZ2lmeShjb21wYXJlZFZhbHVlKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENhc28gbyBhbm8gb3JpZ2luYWwgZGEgZGF0YSBzZWphIGVudHJlIDAgZSAxMDAgYXRyaWJ1aSBlc3NlIHZhbG9yIGFvIGFubywgcG9pcyBvIGBuZXcgRGF0ZWAgZG8gamF2YXNjcmlwdCB0cmFuc2Zvcm1hIG8gYW5vIHBhcmEgMTkwWC5cclxuICogQHBhcmFtIGRhdGUgRGF0YVxyXG4gKiBAcGFyYW0geWVhciBBbm8gb3JpZ2luYWxcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRZZWFyRnJvbTBUbzEwMChkYXRlOiBEYXRlLCB5ZWFyOiBudW1iZXIpIHtcclxuICBpZiAoeWVhciA+PSAwICYmIHllYXIgPCAxMDAgKSB7XHJcbiAgICBkYXRlLnNldEZ1bGxZZWFyKHllYXIpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHNvcnRPcHRpb25zQnlQcm9wZXJ0eShvcHRpb25zOiBBcnJheTxhbnk+LCBwcm9wZXJ0eTogc3RyaW5nKSB7XHJcbiAgb3B0aW9ucy5zb3J0KChvcHRpb25BLCBvcHRpb25CKSA9PiB7XHJcbiAgICBvcHRpb25BID0gb3B0aW9uQVtwcm9wZXJ0eV0udG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgb3B0aW9uQiA9IG9wdGlvbkJbcHJvcGVydHldLnRvU3RyaW5nKCkudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICBpZiAob3B0aW9uQSA8IG9wdGlvbkIpIHtcclxuICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdGlvbkEgPiBvcHRpb25CKSB7XHJcbiAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIDA7XHJcbiAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVEdXBsaWNhdGVkT3B0aW9ucyhsaXN0OiBBcnJheTxhbnk+KSB7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAoaSA9PT0gMCkgeyBjb250aW51ZTsgfVxyXG5cclxuICAgIGlmIChsaXN0LmZpbmRJbmRleChvcCA9PiBvcC52YWx1ZSA9PT0gbGlzdFtpXS52YWx1ZSkgIT09IGkpIHtcclxuICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGktLTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVVbmRlZmluZWRBbmROdWxsT3B0aW9ucyhsaXN0OiBBcnJheTxhbnk+KSB7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICBpZiAobGlzdFtpXS52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IGxpc3RbaV0udmFsdWUgPT09IG51bGwgKSB7XHJcbiAgICAgIGxpc3Quc3BsaWNlKGksIDEpO1xyXG4gICAgICBpLS07XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRWYWx1ZSh2YWx1ZTogYW55KSB7XHJcbiAgcmV0dXJuICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSAnJykgfHwgdmFsdWUgPT09IGZhbHNlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNFeHRlcm5hbExpbmsodXJsKTogYm9vbGVhbiB7XHJcbiAgcmV0dXJuIHVybCA/IHVybC5zdGFydHNXaXRoKCdodHRwJykgOiBmYWxzZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG9wZW5FeHRlcm5hbExpbmsodXJsKTogdm9pZCB7XHJcbiAgd2luZG93Lm9wZW4odXJsLCAnX2JsYW5rJyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiAgZ2V0Rm9ybWF0dGVkTGluayhsaW5rOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gIGxldCBmb3JtYXR0ZWRMaW5rID0gJyc7XHJcbiAgLy8gUmV0aXJhIHRvZG9zIG9zIHBvbnRvcyBubyBjb21lw6dvIGRhIFVSTC5cclxuICBpZiAobGluaykge1xyXG4gICAgZm9ybWF0dGVkTGluayA9IGxpbmsucmVwbGFjZSgvXihcXC4pKy9nLCAnJyk7XHJcbiAgfVxyXG4gIC8vIFZlcmlmaWNhIHNlIGZvaSB1dGlsaXphZG8gdW1hIHJvdGEgcXVlIG7Do28gY29tZWNlIGNvbSBiYXJyYS5cclxuICBpZiAoIWZvcm1hdHRlZExpbmsuc3RhcnRzV2l0aCgnLycpKSB7XHJcbiAgICBmb3JtYXR0ZWRMaW5rID0gJy8nLmNvbmNhdChmb3JtYXR0ZWRMaW5rKTtcclxuICB9XHJcbiAgcmV0dXJuIGZvcm1hdHRlZExpbms7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNw6l0b2RvIHJlc3BvbnPDoXZlbCBwb3Igb3JkZW5hciBkb2lzIHZhbG9yZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSBsZWZ0U2lkZSBQcmltZWlybyB2YWxvciBhIHNlciBjb21wYXJhZG8uXHJcbiAqIEBwYXJhbSByaWdodFNpZGUgU2VndW5kbyB2YWxvciBhIHNlciBjb21wYXJhZG8uXHJcbiAqIEBwYXJhbSBhc2NlbmRpbmcgRGV0ZXJtaW5hIHNlIHNlcsOhIGVtIG9yZGVtIGFzY2VuZGVudGUgb3UgZGVzY2VuZGVudGUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gc29ydFZhbHVlcyhsZWZ0U2lkZTogc3RyaW5nLCByaWdodFNpZGU6IHN0cmluZywgYXNjZW5kaW5nOiBib29sZWFuID0gdHJ1ZSk6IG51bWJlciB7XHJcbiAgaWYgKGFzY2VuZGluZykge1xyXG4gICAgaWYgKGxlZnRTaWRlIDwgcmlnaHRTaWRlKSB7XHJcbiAgICAgIHJldHVybiAtMTtcclxuICAgIH0gZWxzZSBpZiAobGVmdFNpZGUgPiByaWdodFNpZGUpIHtcclxuICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmIChhc2NlbmRpbmcgPT09IGZhbHNlKSB7XHJcbiAgICBpZiAobGVmdFNpZGUgPCByaWdodFNpZGUpIHtcclxuICAgICAgcmV0dXJuIDE7XHJcbiAgICB9IGVsc2UgaWYgKGxlZnRTaWRlID4gcmlnaHRTaWRlKSB7XHJcbiAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICB9XHJcbiAgcmV0dXJuIDA7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZURhdGVSYW5nZShkYXRlOiBEYXRlLCBkYXRlU3RhcnQ6IERhdGUsIGRhdGVFbmQ6IERhdGUpIHtcclxuICBpZiAoZGF0ZVN0YXJ0ICYmIGRhdGVFbmQpIHtcclxuICAgIHJldHVybiAoZGF0ZSA+PSBkYXRlU3RhcnQgJiYgZGF0ZSA8PSBkYXRlRW5kKTtcclxuICB9IGVsc2UgaWYgKGRhdGVTdGFydCAmJiAhZGF0ZUVuZCkge1xyXG4gICAgcmV0dXJuIChkYXRlID49IGRhdGVTdGFydCk7XHJcbiAgfSBlbHNlIGlmICghZGF0ZVN0YXJ0ICYmIGRhdGVFbmQpIHtcclxuICAgIHJldHVybiAoZGF0ZSA8PSBkYXRlRW5kKTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKHRleHQ6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgcmV0dXJuIGAke3RleHQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCl9JHt0ZXh0LnNsaWNlKDEpfWA7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNYXBlaWEgdW0gbm92byBhcnJheSBhcGVuYXMgY29tIGFzIHByb3ByaWVkYWRlcyBkZWZpbmlkYXMgcGVsbyBkZXNlbnZvbHZlZG9yIGJhc2VhZG8gZW0gdW0gYXJyYXkgZGVcclxuICogb3JpZ2VtLlxyXG4gKlxyXG4gKiBFeGVtcGxvOlxyXG4gKlxyXG4gKiBgYGBcclxuICogY29uc3QgcGVvcGxlID0gW1xyXG4gKiAgeyBpZDogMSwgbmFtZTogJ0Z1bGFubycsIGJpcnRoZGF0ZTogJzE5ODAtMTEtMDEnLCBnZW5yZTogJ01hbGUnLCBjaXR5OiAnU8OjbyBQYXVsbycsIGRlcGVuZGVudHM6IDIgfSxcclxuICogIHsgaWQ6IDIsIG5hbWU6ICdCZWx0cmFubycsIGJpcnRoZGF0ZTogJzE5OTctMDEtMjEnLCBnZW5yZTogJ0ZlbWFsZScsIGNpdHk6ICdKb2ludmlsbGUnLCBkZXBlbmRlbnRzOiAwIH0sXHJcbiAqICB7IGlkOiAzLCBuYW1lOiAnU2ljbGFubycsIGJpcnRoZGF0ZTogJzE5OTUtMDctMTUnLCBnZW5yZTogJ01hbGUnLCBjaXR5OiAnSm9pbnZpbGxlJywgZGVwZW5kZW50czogMCB9XHJcbiAqIF07XHJcbiAqXHJcbiAqIGNvbnN0IHByb3BlcnRpZXMgPSBbJ2lkJywgJ25hbWUnXTtcclxuICpcclxuICogY29uc3QgaWRBbmROYW1lID0gbWFwQXJyYXlCeVByb3BlcnRpZXMocGVvcGxlLCBwcm9wZXJ0aWVzKTtcclxuICpcclxuICogY29uc29sZS5sb2coaWRBbmROYW1lKTsgLy8gW3sgaWQ6IDEsIG5hbWU6ICdGdWxhbm8nIH0sIHsgaWQ6IDIsIG5hbWU6ICdCZWx0cmFubycgfSwgeyBpZDogMywgbmFtZTogJ1NpY2xhbm8nIH1dXHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBVbSBvdXRybyB1c28gcGFyYSBvIG3DqXRvZG8gw6kgXCJwYXJlYXJcIiB0b2RvcyBvcyBvYmpldG9zIGRvIGFycmF5IGNvbSBhcyBtZXNtYXMgcHJvcHJpZWRhZGVzLlxyXG4gKlxyXG4gKiBgYGBcclxuICogY29uc3QgY3VzdG9tZXJzID0gW1xyXG4gKiAgeyBpZDogMSwgbmFtZTogJ0Z1bGFubycsIGNpdHk6ICdTw6NvIFBhdWxvJywgZGVwZW5kZW50czogMiB9LCAvLyBzZW0gZ2VucmVcclxuICogIHsgaWQ6IDIsIG5hbWU6ICdCZWx0cmFubycsIGdlbnJlOiAnRmVtYWxlJywgY2l0eTogJ0pvaW52aWxsZScgfSwgLy8gc2VtIGRlcGVuZGVudHNcclxuICogIHsgaWQ6IDMsIG5hbWU6ICdTaWNsYW5vJywgZ2VucmU6ICdNYWxlJywgY2l0eTogJ0pvaW52aWxsZScsIGRlcGVuZGVudHM6IDAgfVxyXG4gKiBdO1xyXG4gKiBjb25zdCBwcm9wZXJ0aWVzID0gWydpZCcsICduYW1lJywgJ2NpdHknLCAnZ2VucmUnLCAnZGVwZW5kZW50cyddO1xyXG4gKlxyXG4gKiBjb25zdCBwYXR0ZXJuID0gbWFwQXJyYXlCeVByb3BlcnRpZXMoY3VzdG9tZXJzLCBwcm9wZXJ0aWVzKTtcclxuICogY29uc29sZS5sb2cocGF0dGVybik7XHJcbiAqXHJcbiAqIC8vIFtcclxuICogLy8gICB7IGlkOiAxLCBuYW1lOiAnRnVsYW5vJywgY2l0eTogJ1PDo28gUGF1bG8nLCBnZW5yZTogdW5kZWZpbmVkLCBkZXBlbmRlbnRzOiAyIH0sXHJcbiAqIC8vICAgeyBpZDogMiwgbmFtZTogJ0JlbHRyYW5vJywgY2l0eTogJ0pvaW52aWxsZScsIGdlbnJlOiAnRmVtYWxlJywgZGVwZW5kZW50czogdW5kZWZpbmVkIH0sXHJcbiAqIC8vICAgeyBpZDogMywgbmFtZTogJ1NpY2xhbm8nLCBjaXR5OiAnSm9pbnZpbGxlJywgZ2VucmU6ICdNYWxlJywgZGVwZW5kZW50czogMCB9XHJcbiAqIC8vIF1cclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSBpdGVtcyB7QXJyYXk8YW55Pn0gQXJyYXkgZGUgaXRlbXMgb3JpZ2luYWwuXHJcbiAqIEBwYXJhbSBwcm9wZXJ0aWVzIHtBcnJheTxzdHJpbmc+fSBBcnJheSBkZSBzdHJpbmcgY29tIGEgbGlzdGEgZGUgcHJvcHJpZWRhZGVzIHF1ZSBkZXZlbSBzZXIgcmV0b3JuYWRhcy5cclxuICpcclxuICogQHJldHVybnMgQXJyYXk8YW55PlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG1hcEFycmF5QnlQcm9wZXJ0aWVzKGl0ZW1zOiBBcnJheTxhbnk+ID0gW10sIHByb3BlcnRpZXM6IEFycmF5PHN0cmluZz4gPSBbXSk6IEFycmF5PGFueT4ge1xyXG4gIHJldHVybiBpdGVtcy5tYXAoaXRlbSA9PiBtYXBPYmplY3RCeVByb3BlcnRpZXMoaXRlbSwgcHJvcGVydGllcykpO1xyXG59XHJcblxyXG4vKipcclxuICogTWFwZWlhIHVtIG5vdm8gb2JqZXRvIGFwZW5hcyBjb20gYXMgcHJvcHJpZWRhZGVzIGRlZmluaWRhcyBwZWxvIGRlc2Vudm9sdmVkb3IuXHJcbiAqXHJcbiAqIEV4ZW1wbG86XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBjb25zdCBwZXJzb24gPSB7IGlkOiAxLCBuYW1lOiAnRnVsYW5vJywgYmlydGhkYXRlOiAnMTk4MC0xMS0wMScsIGdlbnJlOiAnTWFsZScsIGNpdHk6ICdTw6NvIFBhdWxvJywgZGVwZW5kZW50czogMiB9O1xyXG4gKlxyXG4gKiBjb25zdCBwcm9wZXJ0aWVzID0gWydpZCcsICduYW1lJ107XHJcbiAqXHJcbiAqIGNvbnN0IGlkQW5kTmFtZSA9IG1hcE9iamVjdEJ5UHJvcGVydGllcyhwZXJzb24sIHByb3BlcnRpZXMpO1xyXG4gKlxyXG4gKiBjb25zb2xlLmxvZyhpZEFuZE5hbWUpOyAvLyB7IGlkOiAxLCBuYW1lOiAnRnVsYW5vJyB9XHJcbiAqIGBgYFxyXG4gKlxyXG4gKiBAcGFyYW0gb2JqZWN0IHtBcnJheTxhbnk+fSBBcnJheSBkZSBpdGVtcyBvcmlnaW5hbC5cclxuICogQHBhcmFtIHByb3BlcnRpZXMge0FycmF5PHN0cmluZz59IEFycmF5IGRlIHN0cmluZyBjb20gYSBsaXN0YSBkZSBwcm9wcmllZGFkZXMgcXVlIGRldmVtIHNlciByZXRvcm5hZGFzLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBcnJheTxhbnk+XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWFwT2JqZWN0QnlQcm9wZXJ0aWVzKG9iamVjdDogYW55ID0ge30sIHByb3BlcnRpZXM6IEFycmF5PHN0cmluZz4gPSBbXSkge1xyXG4gIGNvbnN0IGdldFNlbGVjdGVkUHJvcGVydGllcyA9IChzZWxlY3RlZFByb3BlcnRpZXMsIHByb3BlcnR5KSA9PiAoeyAuLi5zZWxlY3RlZFByb3BlcnRpZXMsIFtwcm9wZXJ0eV06IG9iamVjdFtwcm9wZXJ0eV0gfSk7XHJcblxyXG4gIHJldHVybiBwcm9wZXJ0aWVzLnJlZHVjZShnZXRTZWxlY3RlZFByb3BlcnRpZXMsIHt9KTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldG9ybmEgb3MgdmFsb3JlcyBkZSB1bSBvYmpldG8gZGVudHJvIGRlIHVtIGFycmF5LlxyXG4gKlxyXG4gKiA+IFNpbXVsYSBvIE9iamVjdC52YWx1ZXMob2JqKSwgbyBtZXNtbyBkZXZlIHNlciByZW1vdmlkbyBhc3NpbSBxdWUgYSB2ZXJzw6NvIHR5cGVzY3JpdCBmb3IgYXR1YWxpemFkYS5cclxuICpcclxuICogQHBhcmFtIG9iamVjdCBPYmpldG8gZGUgb25kZSBzZXLDoSBwZWdvIG9zIHZhbG9yZXMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdmFsdWVzRnJvbU9iamVjdChvYmplY3Q6IGFueSA9IHt9KTogQXJyYXk8YW55PiB7XHJcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkubWFwKHByb3BlcnR5ID0+IG9iamVjdFtwcm9wZXJ0eV0pO1xyXG59XHJcblxyXG4vKipcclxuICogYWRpY2lvbmEgMCBubyB0ZW1wbyBpbmZvcm1hZG8sIGNhc28gbWVub3IgcSAxMFxyXG4gKlxyXG4gKiBAcGFyYW0gdGltZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFkZFplcm8odGltZTogbnVtYmVyKSB7XHJcbiAgaWYgKCF0aW1lKSB7XHJcbiAgICByZXR1cm4gJzAwJztcclxuICB9XHJcblxyXG4gIGlmICh0aW1lIDwgMTApIHtcclxuICAgIHJldHVybiBgMCR7dGltZX1gO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRpbWU7XHJcbn1cclxuIl19