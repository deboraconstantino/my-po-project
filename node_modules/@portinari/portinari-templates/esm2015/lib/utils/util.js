/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
// Idiomas suportados pelas páginas
/** @type {?} */
export const poLocales = ['pt', 'en', 'es', 'ru'];
// Idioma padrão
/** @type {?} */
export const poLocaleDefault = 'pt';
/**
 * @deprecated
 * Utilize o método `getShortBrowserLanguage`.
 *
 * \@description
 * Retorna idioma do browser ou o idioma padrão.
 * @return {?}
 */
export function browserLanguage() {
    return getShortBrowserLanguage();
}
/**
 * Retorna o idioma atual do navegador
 * @return {?}
 */
export function getBrowserLanguage() {
    // navigator.userLanguage is the value for IE10
    return navigator.language || navigator['userLanguage'];
}
/**
 * Retorna o idioma do navegador, com somente as duas primeiras letras. Por exemplo: "pt" ou "es".
 *
 * Caso o valor retornado pelo navegador não estiver dentro dos idiomas suportados pelo PO,
 * será retornado a linguagem padrão (poLocaleDefault).
 * @return {?}
 */
export function getShortBrowserLanguage() {
    /** @type {?} */
    const language = (getBrowserLanguage() || poLocaleDefault).toLowerCase().substring(0, 2);
    if (!poLocales.includes(language)) {
        return poLocaleDefault;
    }
    return language;
}
/**
 * @param {?} val
 * @return {?}
 */
export function convertToBoolean(val) {
    if (typeof val === 'string') {
        val = val.toLowerCase().trim();
        return (val === 'true' || val === 'on' || val === '');
    }
    if (typeof val === 'number') {
        return val === 1;
    }
    return !!val;
}
/**
 * @param {?} value
 * @param {?=} valueDefault
 * @return {?}
 */
export function convertToInt(value, valueDefault) {
    /** @type {?} */
    const validNumber = parseInt(value, 10);
    /** @type {?} */
    const validDefaultValue = parseInt(valueDefault, 10);
    /** @type {?} */
    const defaultValue = validDefaultValue || validDefaultValue === 0 ? validDefaultValue : undefined;
    return validNumber || validNumber === 0 ? validNumber : defaultValue;
}
/**
 * @param {?} object
 * @param {?} type
 * @return {?}
 */
export function isTypeof(object, type) {
    return typeof object === type;
}
/**
 *
 * @param {?} fn Função que será executada dentro do contexto. Podendo ser o nome da função
 * ou a referência da mesma.
 *
 * @param {?} context Contexto do qual a função será executada.
 * @param {?=} param
 * @return {?}
 */
export function callFunction(fn, context, param) {
    if (isTypeof(fn, 'function')) {
        fn.call(context, param);
    }
    else {
        context[fn](param);
    }
}
/**
 * @param {?} value
 * @param {?} start
 * @param {?} end
 * @return {?}
 */
export function convertIsoToDate(value, start, end) {
    if (value) {
        /** @type {?} */
        const day = parseInt(value.substring(8, 10), 10);
        /** @type {?} */
        const month = parseInt(value.substring(5, 7), 10);
        /** @type {?} */
        const year = parseInt(value.substring(0, 4), 10);
        if (start) {
            /** @type {?} */
            const date = new Date(year, month - 1, day, 0, 0, 0);
            setYearFrom0To100(date, year);
            return date;
        }
        else if (end) {
            /** @type {?} */
            const date = new Date(year, month - 1, day, 23, 59, 59);
            setYearFrom0To100(date, year);
            return date;
        }
        else {
            /** @type {?} */
            const milliseconds = Date.parse(value);
            /** @type {?} */
            const timezone = new Date().getTimezoneOffset() * 60000;
            return new Date(milliseconds + timezone);
        }
    }
}
/**
 * @param {?} date
 * @param {?=} time
 * @return {?}
 */
export function convertDateToISOExtended(date, time) {
    if (date) {
        /** @type {?} */
        const getMonth = date.getMonth() + 1;
        /** @type {?} */
        const day = date.getDate() < 10 ? '0' + date.getDate() : date.getDate();
        /** @type {?} */
        const month = getMonth < 10 ? '0' + getMonth : getMonth;
        /** @type {?} */
        const year = formatYear(date.getFullYear());
        /** @type {?} */
        const dateString = date.toString();
        if (time) {
            return year + '-' + month + '-' + day + time;
        }
        else {
            return year + '-' + month + '-' + day + 'T' + dateString.substring(16, 24) +
                dateString.substring(28, 31) + ':' + dateString.substring(31, 33);
        }
    }
    else {
        return null;
    }
}
/**
 * Transforma o ano em uma string no formato yyyy e caso o ano seja menor que 1000 preenche com zeros a esquerda.
 * @param {?} year Ano
 * @return {?}
 */
export function formatYear(year) {
    if (year >= 1000) {
        return year.toString();
    }
    if (year > 99 && year < 1000) {
        return `0${year}`;
    }
    if (year > 9 && year < 100) {
        return `00${year}`;
    }
    if (year >= 0 && year < 10) {
        return `000${year}`;
    }
}
/**
 * @param {?} value
 * @param {?} comparedValue
 * @return {?}
 */
export function isEquals(value, comparedValue) {
    return JSON.stringify(value) === JSON.stringify(comparedValue);
}
/**
 * Caso o ano original da data seja entre 0 e 100 atribui esse valor ao ano, pois o `new Date` do javascript transforma o ano para 190X.
 * @param {?} date Data
 * @param {?} year Ano original
 * @return {?}
 */
export function setYearFrom0To100(date, year) {
    if (year >= 0 && year < 100) {
        date.setFullYear(year);
    }
}
/**
 * @param {?} options
 * @param {?} property
 * @return {?}
 */
export function sortOptionsByProperty(options, property) {
    options.sort((/**
     * @param {?} optionA
     * @param {?} optionB
     * @return {?}
     */
    (optionA, optionB) => {
        optionA = optionA[property].toString().toLowerCase();
        optionB = optionB[property].toString().toLowerCase();
        if (optionA < optionB) {
            return -1;
        }
        if (optionA > optionB) {
            return 1;
        }
        return 0;
    }));
}
/**
 * @param {?} list
 * @return {?}
 */
export function removeDuplicatedOptions(list) {
    for (let i = 0; i < list.length; i++) {
        if (i === 0) {
            continue;
        }
        if (list.findIndex((/**
         * @param {?} op
         * @return {?}
         */
        op => op.value === list[i].value)) !== i) {
            list.splice(i, 1);
            i--;
        }
    }
}
/**
 * @param {?} list
 * @return {?}
 */
export function removeUndefinedAndNullOptions(list) {
    for (let i = 0; i < list.length; i++) {
        if (list[i].value === undefined || list[i].value === null) {
            list.splice(i, 1);
            i--;
        }
    }
}
/**
 * @param {?} value
 * @return {?}
 */
export function validValue(value) {
    return (value !== null && value !== undefined && value !== '') || value === false;
}
/**
 * @param {?} url
 * @return {?}
 */
export function isExternalLink(url) {
    return url ? url.startsWith('http') : false;
}
/**
 * @param {?} url
 * @return {?}
 */
export function openExternalLink(url) {
    window.open(url, '_blank');
}
/**
 * @param {?} link
 * @return {?}
 */
export function getFormattedLink(link) {
    /** @type {?} */
    let formattedLink = '';
    // Retira todos os pontos no começo da URL.
    if (link) {
        formattedLink = link.replace(/^(\.)+/g, '');
    }
    // Verifica se foi utilizado uma rota que não comece com barra.
    if (!formattedLink.startsWith('/')) {
        formattedLink = '/'.concat(formattedLink);
    }
    return formattedLink;
}
/**
 * Método responsável por ordenar dois valores.
 *
 * @param {?} leftSide Primeiro valor a ser comparado.
 * @param {?} rightSide Segundo valor a ser comparado.
 * @param {?=} ascending Determina se será em ordem ascendente ou descendente.
 * @return {?}
 */
export function sortValues(leftSide, rightSide, ascending = true) {
    if (ascending) {
        if (leftSide < rightSide) {
            return -1;
        }
        else if (leftSide > rightSide) {
            return 1;
        }
    }
    else if (ascending === false) {
        if (leftSide < rightSide) {
            return 1;
        }
        else if (leftSide > rightSide) {
            return -1;
        }
    }
    return 0;
}
/**
 * @param {?} date
 * @param {?} dateStart
 * @param {?} dateEnd
 * @return {?}
 */
export function validateDateRange(date, dateStart, dateEnd) {
    if (dateStart && dateEnd) {
        return (date >= dateStart && date <= dateEnd);
    }
    else if (dateStart && !dateEnd) {
        return (date >= dateStart);
    }
    else if (!dateStart && dateEnd) {
        return (date <= dateEnd);
    }
    else {
        return true;
    }
}
/**
 * @param {?} text
 * @return {?}
 */
export function capitalizeFirstLetter(text) {
    return `${text.charAt(0).toUpperCase()}${text.slice(1)}`;
}
/**
 * Mapeia um novo array apenas com as propriedades definidas pelo desenvolvedor baseado em um array de
 * origem.
 *
 * Exemplo:
 *
 * ```
 * const people = [
 *  { id: 1, name: 'Fulano', birthdate: '1980-11-01', genre: 'Male', city: 'São Paulo', dependents: 2 },
 *  { id: 2, name: 'Beltrano', birthdate: '1997-01-21', genre: 'Female', city: 'Joinville', dependents: 0 },
 *  { id: 3, name: 'Siclano', birthdate: '1995-07-15', genre: 'Male', city: 'Joinville', dependents: 0 }
 * ];
 *
 * const properties = ['id', 'name'];
 *
 * const idAndName = mapArrayByProperties(people, properties);
 *
 * console.log(idAndName); // [{ id: 1, name: 'Fulano' }, { id: 2, name: 'Beltrano' }, { id: 3, name: 'Siclano' }]
 * ```
 *
 * Um outro uso para o método é "parear" todos os objetos do array com as mesmas propriedades.
 *
 * ```
 * const customers = [
 *  { id: 1, name: 'Fulano', city: 'São Paulo', dependents: 2 }, // sem genre
 *  { id: 2, name: 'Beltrano', genre: 'Female', city: 'Joinville' }, // sem dependents
 *  { id: 3, name: 'Siclano', genre: 'Male', city: 'Joinville', dependents: 0 }
 * ];
 * const properties = ['id', 'name', 'city', 'genre', 'dependents'];
 *
 * const pattern = mapArrayByProperties(customers, properties);
 * console.log(pattern);
 *
 * // [
 * //   { id: 1, name: 'Fulano', city: 'São Paulo', genre: undefined, dependents: 2 },
 * //   { id: 2, name: 'Beltrano', city: 'Joinville', genre: 'Female', dependents: undefined },
 * //   { id: 3, name: 'Siclano', city: 'Joinville', genre: 'Male', dependents: 0 }
 * // ]
 * ```
 *
 * @param {?=} items {Array<any>} Array de items original.
 * @param {?=} properties {Array<string>} Array de string com a lista de propriedades que devem ser retornadas.
 *
 * @return {?} Array<any>
 */
export function mapArrayByProperties(items = [], properties = []) {
    return items.map((/**
     * @param {?} item
     * @return {?}
     */
    item => mapObjectByProperties(item, properties)));
}
/**
 * Mapeia um novo objeto apenas com as propriedades definidas pelo desenvolvedor.
 *
 * Exemplo:
 *
 * ```
 * const person = { id: 1, name: 'Fulano', birthdate: '1980-11-01', genre: 'Male', city: 'São Paulo', dependents: 2 };
 *
 * const properties = ['id', 'name'];
 *
 * const idAndName = mapObjectByProperties(person, properties);
 *
 * console.log(idAndName); // { id: 1, name: 'Fulano' }
 * ```
 *
 * @param {?=} object {Array<any>} Array de items original.
 * @param {?=} properties {Array<string>} Array de string com a lista de propriedades que devem ser retornadas.
 *
 * @return {?} Array<any>
 */
export function mapObjectByProperties(object = {}, properties = []) {
    /** @type {?} */
    const getSelectedProperties = (/**
     * @param {?} selectedProperties
     * @param {?} property
     * @return {?}
     */
    (selectedProperties, property) => (Object.assign({}, selectedProperties, { [property]: object[property] })));
    return properties.reduce(getSelectedProperties, {});
}
/**
 * Retorna os valores de um objeto dentro de um array.
 *
 * > Simula o Object.values(obj), o mesmo deve ser removido assim que a versão typescrit for atualizada.
 *
 * @param {?=} object Objeto de onde será pego os valores.
 * @return {?}
 */
export function valuesFromObject(object = {}) {
    return Object.keys(object).map((/**
     * @param {?} property
     * @return {?}
     */
    property => object[property]));
}
/**
 * adiciona 0 no tempo informado, caso menor q 10
 *
 * @param {?} time
 * @return {?}
 */
export function addZero(time) {
    if (!time) {
        return '00';
    }
    if (time < 10) {
        return `0${time}`;
    }
    return time;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0Bwb3J0aW5hcmkvcG9ydGluYXJpLXRlbXBsYXRlcy8iLCJzb3VyY2VzIjpbImxpYi91dGlscy91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBLE1BQU0sT0FBTyxTQUFTLEdBQUcsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLENBQUM7OztBQUVqRCxNQUFNLE9BQU8sZUFBZSxHQUFHLElBQUk7Ozs7Ozs7OztBQVNuQyxNQUFNLFVBQVUsZUFBZTtJQUM3QixPQUFPLHVCQUF1QixFQUFFLENBQUM7QUFDbkMsQ0FBQzs7Ozs7QUFLRCxNQUFNLFVBQVUsa0JBQWtCO0lBQ2hDLCtDQUErQztJQUMvQyxPQUFPLFNBQVMsQ0FBQyxRQUFRLElBQUksU0FBUyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0FBQ3pELENBQUM7Ozs7Ozs7O0FBUUQsTUFBTSxVQUFVLHVCQUF1Qjs7VUFDL0IsUUFBUSxHQUFHLENBQUMsa0JBQWtCLEVBQUUsSUFBSSxlQUFlLENBQUMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUV4RixJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsRUFBRTtRQUNqQyxPQUFPLGVBQWUsQ0FBQztLQUN4QjtJQUVELE9BQU8sUUFBUSxDQUFDO0FBQ2xCLENBQUM7Ozs7O0FBRUQsTUFBTSxVQUFVLGdCQUFnQixDQUFDLEdBQVE7SUFDdkMsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUU7UUFDM0IsR0FBRyxHQUFHLEdBQUcsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUMvQixPQUFPLENBQUMsR0FBRyxLQUFLLE1BQU0sSUFBSSxHQUFHLEtBQUssSUFBSSxJQUFJLEdBQUcsS0FBSyxFQUFFLENBQUMsQ0FBQztLQUN2RDtJQUVELElBQUksT0FBTyxHQUFHLEtBQUssUUFBUSxFQUFFO1FBQzNCLE9BQU8sR0FBRyxLQUFLLENBQUMsQ0FBQztLQUNsQjtJQUVELE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQztBQUNmLENBQUM7Ozs7OztBQUVELE1BQU0sVUFBVSxZQUFZLENBQUMsS0FBVSxFQUFFLFlBQWtCOztVQUNuRCxXQUFXLEdBQUcsUUFBUSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7O1VBQ2pDLGlCQUFpQixHQUFHLFFBQVEsQ0FBQyxZQUFZLEVBQUUsRUFBRSxDQUFDOztVQUM5QyxZQUFZLEdBQUcsaUJBQWlCLElBQUksaUJBQWlCLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsU0FBUztJQUVqRyxPQUFPLFdBQVcsSUFBSSxXQUFXLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLFlBQVksQ0FBQztBQUN2RSxDQUFDOzs7Ozs7QUFFRCxNQUFNLFVBQVUsUUFBUSxDQUFDLE1BQVcsRUFBRSxJQUFTO0lBQzdDLE9BQU8sT0FBTyxNQUFNLEtBQUssSUFBSSxDQUFDO0FBQ2hDLENBQUM7Ozs7Ozs7Ozs7QUFTRCxNQUFNLFVBQVUsWUFBWSxDQUFDLEVBQU8sRUFBRSxPQUFZLEVBQUUsS0FBTTtJQUN4RCxJQUFJLFFBQVEsQ0FBQyxFQUFFLEVBQUUsVUFBVSxDQUFDLEVBQUU7UUFDNUIsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsS0FBSyxDQUFDLENBQUM7S0FDekI7U0FBTTtRQUNMLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUNwQjtBQUNILENBQUM7Ozs7Ozs7QUFFRCxNQUFNLFVBQVUsZ0JBQWdCLENBQUMsS0FBYSxFQUFHLEtBQWMsRUFBRSxHQUFZO0lBQzNFLElBQUksS0FBSyxFQUFFOztjQUNILEdBQUcsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDOztjQUMxQyxLQUFLLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQzs7Y0FDM0MsSUFBSSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUM7UUFDaEQsSUFBSSxLQUFLLEVBQUU7O2tCQUNILElBQUksR0FBRyxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUUsS0FBSyxHQUFHLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7WUFFcEQsaUJBQWlCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1lBRTlCLE9BQU8sSUFBSSxDQUFDO1NBQ2I7YUFBTSxJQUFJLEdBQUcsRUFBRTs7a0JBQ1IsSUFBSSxHQUFHLElBQUksSUFBSSxDQUFDLElBQUksRUFBRSxLQUFLLEdBQUcsQ0FBQyxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsQ0FBQztZQUV2RCxpQkFBaUIsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7WUFFOUIsT0FBTyxJQUFJLENBQUM7U0FDYjthQUFNOztrQkFDQyxZQUFZLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUM7O2tCQUNoQyxRQUFRLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQyxpQkFBaUIsRUFBRSxHQUFHLEtBQUs7WUFDdkQsT0FBTyxJQUFJLElBQUksQ0FBQyxZQUFZLEdBQUcsUUFBUSxDQUFDLENBQUM7U0FDMUM7S0FDRjtBQUNILENBQUM7Ozs7OztBQUVELE1BQU0sVUFBVSx3QkFBd0IsQ0FBQyxJQUFVLEVBQUUsSUFBYTtJQUNoRSxJQUFJLElBQUksRUFBRTs7Y0FFRixRQUFRLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUM7O2NBQzlCLEdBQUcsR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFOztjQUNqRSxLQUFLLEdBQUcsUUFBUSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsUUFBUTs7Y0FDakQsSUFBSSxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7O2NBRXJDLFVBQVUsR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFO1FBRWxDLElBQUksSUFBSSxFQUFFO1lBQ1IsT0FBTyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQztTQUM5QzthQUFNO1lBQ0wsT0FBTyxJQUFJLEdBQUcsR0FBRyxHQUFHLEtBQUssR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxVQUFVLENBQUMsU0FBUyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUM7Z0JBQ3RFLFVBQVUsQ0FBQyxTQUFTLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxHQUFHLEdBQUcsR0FBRyxVQUFVLENBQUMsU0FBUyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztTQUN2RTtLQUNGO1NBQU07UUFDTCxPQUFPLElBQUksQ0FBQztLQUNiO0FBQ0gsQ0FBQzs7Ozs7O0FBTUQsTUFBTSxVQUFVLFVBQVUsQ0FBQyxJQUFZO0lBRXJDLElBQUksSUFBSSxJQUFJLElBQUksRUFBRTtRQUNoQixPQUFPLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztLQUN4QjtJQUVELElBQUksSUFBSSxHQUFHLEVBQUUsSUFBSSxJQUFJLEdBQUcsSUFBSSxFQUFFO1FBQzVCLE9BQU8sSUFBSSxJQUFJLEVBQUUsQ0FBQztLQUNuQjtJQUVELElBQUksSUFBSSxHQUFHLENBQUMsSUFBSSxJQUFJLEdBQUcsR0FBRyxFQUFFO1FBQzFCLE9BQU8sS0FBSyxJQUFJLEVBQUUsQ0FBQztLQUNwQjtJQUVELElBQUksSUFBSSxJQUFJLENBQUMsSUFBSSxJQUFJLEdBQUcsRUFBRSxFQUFFO1FBQzFCLE9BQU8sTUFBTSxJQUFJLEVBQUUsQ0FBQztLQUNyQjtBQUVILENBQUM7Ozs7OztBQUVELE1BQU0sVUFBVSxRQUFRLENBQUMsS0FBSyxFQUFFLGFBQWE7SUFDM0MsT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxLQUFLLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLENBQUM7QUFDakUsQ0FBQzs7Ozs7OztBQU9ELE1BQU0sVUFBVSxpQkFBaUIsQ0FBQyxJQUFVLEVBQUUsSUFBWTtJQUN4RCxJQUFJLElBQUksSUFBSSxDQUFDLElBQUksSUFBSSxHQUFHLEdBQUcsRUFBRztRQUM1QixJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO0tBQ3hCO0FBQ0gsQ0FBQzs7Ozs7O0FBRUQsTUFBTSxVQUFVLHFCQUFxQixDQUFDLE9BQW1CLEVBQUUsUUFBZ0I7SUFDekUsT0FBTyxDQUFDLElBQUk7Ozs7O0lBQUMsQ0FBQyxPQUFPLEVBQUUsT0FBTyxFQUFFLEVBQUU7UUFDaEMsT0FBTyxHQUFHLE9BQU8sQ0FBQyxRQUFRLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUNyRCxPQUFPLEdBQUcsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBRXJELElBQUksT0FBTyxHQUFHLE9BQU8sRUFBRTtZQUNyQixPQUFPLENBQUMsQ0FBQyxDQUFDO1NBQ1g7UUFDRCxJQUFJLE9BQU8sR0FBRyxPQUFPLEVBQUU7WUFDckIsT0FBTyxDQUFDLENBQUM7U0FDVjtRQUNELE9BQU8sQ0FBQyxDQUFDO0lBQ1gsQ0FBQyxFQUFDLENBQUM7QUFDTCxDQUFDOzs7OztBQUVELE1BQU0sVUFBVSx1QkFBdUIsQ0FBQyxJQUFnQjtJQUN0RCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtRQUNwQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFBRSxTQUFTO1NBQUU7UUFFMUIsSUFBSSxJQUFJLENBQUMsU0FBUzs7OztRQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEtBQUssS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxFQUFDLEtBQUssQ0FBQyxFQUFFO1lBQzFELElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ2xCLENBQUMsRUFBRSxDQUFDO1NBQ0w7S0FDRjtBQUNILENBQUM7Ozs7O0FBRUQsTUFBTSxVQUFVLDZCQUE2QixDQUFDLElBQWdCO0lBQzVELEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ3BDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssS0FBSyxTQUFTLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssS0FBSyxJQUFJLEVBQUc7WUFDMUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDbEIsQ0FBQyxFQUFFLENBQUM7U0FDTDtLQUNGO0FBQ0gsQ0FBQzs7Ozs7QUFFRCxNQUFNLFVBQVUsVUFBVSxDQUFDLEtBQVU7SUFDbkMsT0FBTyxDQUFDLEtBQUssS0FBSyxJQUFJLElBQUksS0FBSyxLQUFLLFNBQVMsSUFBSSxLQUFLLEtBQUssRUFBRSxDQUFDLElBQUksS0FBSyxLQUFLLEtBQUssQ0FBQztBQUNwRixDQUFDOzs7OztBQUVELE1BQU0sVUFBVSxjQUFjLENBQUMsR0FBRztJQUNoQyxPQUFPLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDO0FBQzlDLENBQUM7Ozs7O0FBRUQsTUFBTSxVQUFVLGdCQUFnQixDQUFDLEdBQUc7SUFDbEMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFDN0IsQ0FBQzs7Ozs7QUFFRCxNQUFNLFVBQVcsZ0JBQWdCLENBQUMsSUFBWTs7UUFDeEMsYUFBYSxHQUFHLEVBQUU7SUFDdEIsMkNBQTJDO0lBQzNDLElBQUksSUFBSSxFQUFFO1FBQ1IsYUFBYSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0tBQzdDO0lBQ0QsK0RBQStEO0lBQy9ELElBQUksQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQ2xDLGFBQWEsR0FBRyxHQUFHLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDO0tBQzNDO0lBQ0QsT0FBTyxhQUFhLENBQUM7QUFDdkIsQ0FBQzs7Ozs7Ozs7O0FBU0QsTUFBTSxVQUFVLFVBQVUsQ0FBQyxRQUFnQixFQUFFLFNBQWlCLEVBQUUsWUFBcUIsSUFBSTtJQUN2RixJQUFJLFNBQVMsRUFBRTtRQUNiLElBQUksUUFBUSxHQUFHLFNBQVMsRUFBRTtZQUN4QixPQUFPLENBQUMsQ0FBQyxDQUFDO1NBQ1g7YUFBTSxJQUFJLFFBQVEsR0FBRyxTQUFTLEVBQUU7WUFDL0IsT0FBTyxDQUFDLENBQUM7U0FDVjtLQUNGO1NBQU0sSUFBSSxTQUFTLEtBQUssS0FBSyxFQUFFO1FBQzlCLElBQUksUUFBUSxHQUFHLFNBQVMsRUFBRTtZQUN4QixPQUFPLENBQUMsQ0FBQztTQUNWO2FBQU0sSUFBSSxRQUFRLEdBQUcsU0FBUyxFQUFFO1lBQy9CLE9BQU8sQ0FBQyxDQUFDLENBQUM7U0FDWDtLQUNGO0lBQ0QsT0FBTyxDQUFDLENBQUM7QUFDWCxDQUFDOzs7Ozs7O0FBRUQsTUFBTSxVQUFVLGlCQUFpQixDQUFDLElBQVUsRUFBRSxTQUFlLEVBQUUsT0FBYTtJQUMxRSxJQUFJLFNBQVMsSUFBSSxPQUFPLEVBQUU7UUFDeEIsT0FBTyxDQUFDLElBQUksSUFBSSxTQUFTLElBQUksSUFBSSxJQUFJLE9BQU8sQ0FBQyxDQUFDO0tBQy9DO1NBQU0sSUFBSSxTQUFTLElBQUksQ0FBQyxPQUFPLEVBQUU7UUFDaEMsT0FBTyxDQUFDLElBQUksSUFBSSxTQUFTLENBQUMsQ0FBQztLQUM1QjtTQUFNLElBQUksQ0FBQyxTQUFTLElBQUksT0FBTyxFQUFFO1FBQ2hDLE9BQU8sQ0FBQyxJQUFJLElBQUksT0FBTyxDQUFDLENBQUM7S0FDMUI7U0FBTTtRQUNMLE9BQU8sSUFBSSxDQUFDO0tBQ2I7QUFDSCxDQUFDOzs7OztBQUVELE1BQU0sVUFBVSxxQkFBcUIsQ0FBQyxJQUFZO0lBQ2hELE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztBQUMzRCxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0NELE1BQU0sVUFBVSxvQkFBb0IsQ0FBQyxRQUFvQixFQUFFLEVBQUUsYUFBNEIsRUFBRTtJQUN6RixPQUFPLEtBQUssQ0FBQyxHQUFHOzs7O0lBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLEVBQUMsQ0FBQztBQUNwRSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkQsTUFBTSxVQUFVLHFCQUFxQixDQUFDLFNBQWMsRUFBRSxFQUFFLGFBQTRCLEVBQUU7O1VBQzlFLHFCQUFxQjs7Ozs7SUFBRyxDQUFDLGtCQUFrQixFQUFFLFFBQVEsRUFBRSxFQUFFLENBQUMsbUJBQU0sa0JBQWtCLElBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUcsQ0FBQTtJQUV6SCxPQUFPLFVBQVUsQ0FBQyxNQUFNLENBQUMscUJBQXFCLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDdEQsQ0FBQzs7Ozs7Ozs7O0FBU0QsTUFBTSxVQUFVLGdCQUFnQixDQUFDLFNBQWMsRUFBRTtJQUMvQyxPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRzs7OztJQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxFQUFDLENBQUM7QUFDL0QsQ0FBQzs7Ozs7OztBQU9ELE1BQU0sVUFBVSxPQUFPLENBQUMsSUFBWTtJQUNsQyxJQUFJLENBQUMsSUFBSSxFQUFFO1FBQ1QsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUVELElBQUksSUFBSSxHQUFHLEVBQUUsRUFBRTtRQUNiLE9BQU8sSUFBSSxJQUFJLEVBQUUsQ0FBQztLQUNuQjtJQUVELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIElkaW9tYXMgc3Vwb3J0YWRvcyBwZWxhcyBww6FnaW5hc1xyXG5leHBvcnQgY29uc3QgcG9Mb2NhbGVzID0gWydwdCcsICdlbicsICdlcycsICdydSddO1xyXG4vLyBJZGlvbWEgcGFkcsOjb1xyXG5leHBvcnQgY29uc3QgcG9Mb2NhbGVEZWZhdWx0ID0gJ3B0JztcclxuXHJcbi8qKlxyXG4gKiBAZGVwcmVjYXRlZFxyXG4gKiBVdGlsaXplIG8gbcOpdG9kbyBgZ2V0U2hvcnRCcm93c2VyTGFuZ3VhZ2VgLlxyXG4gKlxyXG4gKiBAZGVzY3JpcHRpb25cclxuICogUmV0b3JuYSBpZGlvbWEgZG8gYnJvd3NlciBvdSBvIGlkaW9tYSBwYWRyw6NvLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGJyb3dzZXJMYW5ndWFnZSgpIHtcclxuICByZXR1cm4gZ2V0U2hvcnRCcm93c2VyTGFuZ3VhZ2UoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldG9ybmEgbyBpZGlvbWEgYXR1YWwgZG8gbmF2ZWdhZG9yXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QnJvd3Nlckxhbmd1YWdlKCk6IHN0cmluZyB7XHJcbiAgLy8gbmF2aWdhdG9yLnVzZXJMYW5ndWFnZSBpcyB0aGUgdmFsdWUgZm9yIElFMTBcclxuICByZXR1cm4gbmF2aWdhdG9yLmxhbmd1YWdlIHx8IG5hdmlnYXRvclsndXNlckxhbmd1YWdlJ107XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXRvcm5hIG8gaWRpb21hIGRvIG5hdmVnYWRvciwgY29tIHNvbWVudGUgYXMgZHVhcyBwcmltZWlyYXMgbGV0cmFzLiBQb3IgZXhlbXBsbzogXCJwdFwiIG91IFwiZXNcIi5cclxuICpcclxuICogQ2FzbyBvIHZhbG9yIHJldG9ybmFkbyBwZWxvIG5hdmVnYWRvciBuw6NvIGVzdGl2ZXIgZGVudHJvIGRvcyBpZGlvbWFzIHN1cG9ydGFkb3MgcGVsbyBQTyxcclxuICogc2Vyw6EgcmV0b3JuYWRvIGEgbGluZ3VhZ2VtIHBhZHLDo28gKHBvTG9jYWxlRGVmYXVsdCkuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2hvcnRCcm93c2VyTGFuZ3VhZ2UoKTogc3RyaW5nIHtcclxuICBjb25zdCBsYW5ndWFnZSA9IChnZXRCcm93c2VyTGFuZ3VhZ2UoKSB8fCBwb0xvY2FsZURlZmF1bHQpLnRvTG93ZXJDYXNlKCkuc3Vic3RyaW5nKDAsIDIpO1xyXG5cclxuICBpZiAoIXBvTG9jYWxlcy5pbmNsdWRlcyhsYW5ndWFnZSkpIHtcclxuICAgIHJldHVybiBwb0xvY2FsZURlZmF1bHQ7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbGFuZ3VhZ2U7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VG9Cb29sZWFuKHZhbDogYW55KTogYm9vbGVhbiB7XHJcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICB2YWwgPSB2YWwudG9Mb3dlckNhc2UoKS50cmltKCk7XHJcbiAgICByZXR1cm4gKHZhbCA9PT0gJ3RydWUnIHx8IHZhbCA9PT0gJ29uJyB8fCB2YWwgPT09ICcnKTtcclxuICB9XHJcblxyXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xyXG4gICAgcmV0dXJuIHZhbCA9PT0gMTtcclxuICB9XHJcblxyXG4gIHJldHVybiAhIXZhbDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRUb0ludCh2YWx1ZTogYW55LCB2YWx1ZURlZmF1bHQ/OiBhbnkpOiBudW1iZXIge1xyXG4gIGNvbnN0IHZhbGlkTnVtYmVyID0gcGFyc2VJbnQodmFsdWUsIDEwKTtcclxuICBjb25zdCB2YWxpZERlZmF1bHRWYWx1ZSA9IHBhcnNlSW50KHZhbHVlRGVmYXVsdCwgMTApO1xyXG4gIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHZhbGlkRGVmYXVsdFZhbHVlIHx8IHZhbGlkRGVmYXVsdFZhbHVlID09PSAwID8gdmFsaWREZWZhdWx0VmFsdWUgOiB1bmRlZmluZWQ7XHJcblxyXG4gIHJldHVybiB2YWxpZE51bWJlciB8fCB2YWxpZE51bWJlciA9PT0gMCA/IHZhbGlkTnVtYmVyIDogZGVmYXVsdFZhbHVlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNUeXBlb2Yob2JqZWN0OiBhbnksIHR5cGU6IGFueSkge1xyXG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSB0eXBlO1xyXG59XHJcblxyXG4vKipcclxuICpcclxuICogQHBhcmFtIGZuIEZ1bsOnw6NvIHF1ZSBzZXLDoSBleGVjdXRhZGEgZGVudHJvIGRvIGNvbnRleHRvLiBQb2RlbmRvIHNlciBvIG5vbWUgZGEgZnVuw6fDo29cclxuICogb3UgYSByZWZlcsOqbmNpYSBkYSBtZXNtYS5cclxuICpcclxuICogQHBhcmFtIGNvbnRleHQgQ29udGV4dG8gZG8gcXVhbCBhIGZ1bsOnw6NvIHNlcsOhIGV4ZWN1dGFkYS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxsRnVuY3Rpb24oZm46IGFueSwgY29udGV4dDogYW55LCBwYXJhbT8pOiB2b2lkIHtcclxuICBpZiAoaXNUeXBlb2YoZm4sICdmdW5jdGlvbicpKSB7XHJcbiAgICBmbi5jYWxsKGNvbnRleHQsIHBhcmFtKTtcclxuICB9IGVsc2Uge1xyXG4gICAgY29udGV4dFtmbl0ocGFyYW0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRJc29Ub0RhdGUodmFsdWU6IHN0cmluZyAsIHN0YXJ0OiBib29sZWFuLCBlbmQ6IGJvb2xlYW4pIHtcclxuICBpZiAodmFsdWUpIHtcclxuICAgIGNvbnN0IGRheSA9IHBhcnNlSW50KHZhbHVlLnN1YnN0cmluZyg4LCAxMCksIDEwKTtcclxuICAgIGNvbnN0IG1vbnRoID0gcGFyc2VJbnQodmFsdWUuc3Vic3RyaW5nKDUsIDcpLCAxMCk7XHJcbiAgICBjb25zdCB5ZWFyID0gcGFyc2VJbnQodmFsdWUuc3Vic3RyaW5nKDAsIDQpLCAxMCk7XHJcbiAgICBpZiAoc3RhcnQpIHtcclxuICAgICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKHllYXIsIG1vbnRoIC0gMSwgZGF5LCAwLCAwLCAwKTtcclxuXHJcbiAgICAgIHNldFllYXJGcm9tMFRvMTAwKGRhdGUsIHllYXIpO1xyXG5cclxuICAgICAgcmV0dXJuIGRhdGU7XHJcbiAgICB9IGVsc2UgaWYgKGVuZCkge1xyXG4gICAgICBjb25zdCBkYXRlID0gbmV3IERhdGUoeWVhciwgbW9udGggLSAxLCBkYXksIDIzLCA1OSwgNTkpO1xyXG5cclxuICAgICAgc2V0WWVhckZyb20wVG8xMDAoZGF0ZSwgeWVhcik7XHJcblxyXG4gICAgICByZXR1cm4gZGF0ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnN0IG1pbGxpc2Vjb25kcyA9IERhdGUucGFyc2UodmFsdWUpO1xyXG4gICAgICBjb25zdCB0aW1lem9uZSA9IG5ldyBEYXRlKCkuZ2V0VGltZXpvbmVPZmZzZXQoKSAqIDYwMDAwO1xyXG4gICAgICByZXR1cm4gbmV3IERhdGUobWlsbGlzZWNvbmRzICsgdGltZXpvbmUpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnREYXRlVG9JU09FeHRlbmRlZChkYXRlOiBEYXRlLCB0aW1lPzogc3RyaW5nKSB7XHJcbiAgaWYgKGRhdGUpIHtcclxuXHJcbiAgICBjb25zdCBnZXRNb250aCA9IGRhdGUuZ2V0TW9udGgoKSArIDE7XHJcbiAgICBjb25zdCBkYXkgPSBkYXRlLmdldERhdGUoKSA8IDEwID8gJzAnICsgZGF0ZS5nZXREYXRlKCkgOiBkYXRlLmdldERhdGUoKTtcclxuICAgIGNvbnN0IG1vbnRoID0gZ2V0TW9udGggPCAxMCA/ICcwJyArIGdldE1vbnRoIDogZ2V0TW9udGg7XHJcbiAgICBjb25zdCB5ZWFyID0gZm9ybWF0WWVhcihkYXRlLmdldEZ1bGxZZWFyKCkpO1xyXG5cclxuICAgIGNvbnN0IGRhdGVTdHJpbmcgPSBkYXRlLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgaWYgKHRpbWUpIHtcclxuICAgICAgcmV0dXJuIHllYXIgKyAnLScgKyBtb250aCArICctJyArIGRheSArIHRpbWU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4geWVhciArICctJyArIG1vbnRoICsgJy0nICsgZGF5ICsgJ1QnICsgZGF0ZVN0cmluZy5zdWJzdHJpbmcoMTYsIDI0KSArXHJcbiAgICAgICAgICBkYXRlU3RyaW5nLnN1YnN0cmluZygyOCwgMzEpICsgJzonICsgZGF0ZVN0cmluZy5zdWJzdHJpbmcoMzEsIDMzKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogVHJhbnNmb3JtYSBvIGFubyBlbSB1bWEgc3RyaW5nIG5vIGZvcm1hdG8geXl5eSBlIGNhc28gbyBhbm8gc2VqYSBtZW5vciBxdWUgMTAwMCBwcmVlbmNoZSBjb20gemVyb3MgYSBlc3F1ZXJkYS5cclxuICogQHBhcmFtIHllYXIgQW5vXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0WWVhcih5ZWFyOiBudW1iZXIpIHtcclxuXHJcbiAgaWYgKHllYXIgPj0gMTAwMCkge1xyXG4gICAgcmV0dXJuIHllYXIudG9TdHJpbmcoKTtcclxuICB9XHJcblxyXG4gIGlmICh5ZWFyID4gOTkgJiYgeWVhciA8IDEwMDApIHtcclxuICAgIHJldHVybiBgMCR7eWVhcn1gO1xyXG4gIH1cclxuXHJcbiAgaWYgKHllYXIgPiA5ICYmIHllYXIgPCAxMDApIHtcclxuICAgIHJldHVybiBgMDAke3llYXJ9YDtcclxuICB9XHJcblxyXG4gIGlmICh5ZWFyID49IDAgJiYgeWVhciA8IDEwKSB7XHJcbiAgICByZXR1cm4gYDAwMCR7eWVhcn1gO1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0VxdWFscyh2YWx1ZSwgY29tcGFyZWRWYWx1ZSkge1xyXG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgPT09IEpTT04uc3RyaW5naWZ5KGNvbXBhcmVkVmFsdWUpO1xyXG59XHJcblxyXG4vKipcclxuICogQ2FzbyBvIGFubyBvcmlnaW5hbCBkYSBkYXRhIHNlamEgZW50cmUgMCBlIDEwMCBhdHJpYnVpIGVzc2UgdmFsb3IgYW8gYW5vLCBwb2lzIG8gYG5ldyBEYXRlYCBkbyBqYXZhc2NyaXB0IHRyYW5zZm9ybWEgbyBhbm8gcGFyYSAxOTBYLlxyXG4gKiBAcGFyYW0gZGF0ZSBEYXRhXHJcbiAqIEBwYXJhbSB5ZWFyIEFubyBvcmlnaW5hbFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHNldFllYXJGcm9tMFRvMTAwKGRhdGU6IERhdGUsIHllYXI6IG51bWJlcikge1xyXG4gIGlmICh5ZWFyID49IDAgJiYgeWVhciA8IDEwMCApIHtcclxuICAgIGRhdGUuc2V0RnVsbFllYXIoeWVhcik7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gc29ydE9wdGlvbnNCeVByb3BlcnR5KG9wdGlvbnM6IEFycmF5PGFueT4sIHByb3BlcnR5OiBzdHJpbmcpIHtcclxuICBvcHRpb25zLnNvcnQoKG9wdGlvbkEsIG9wdGlvbkIpID0+IHtcclxuICAgIG9wdGlvbkEgPSBvcHRpb25BW3Byb3BlcnR5XS50b1N0cmluZygpLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBvcHRpb25CID0gb3B0aW9uQltwcm9wZXJ0eV0udG9TdHJpbmcoKS50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgIGlmIChvcHRpb25BIDwgb3B0aW9uQikge1xyXG4gICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBpZiAob3B0aW9uQSA+IG9wdGlvbkIpIHtcclxuICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gMDtcclxuICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZUR1cGxpY2F0ZWRPcHRpb25zKGxpc3Q6IEFycmF5PGFueT4pIHtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmIChpID09PSAwKSB7IGNvbnRpbnVlOyB9XHJcblxyXG4gICAgaWYgKGxpc3QuZmluZEluZGV4KG9wID0+IG9wLnZhbHVlID09PSBsaXN0W2ldLnZhbHVlKSAhPT0gaSkge1xyXG4gICAgICBsaXN0LnNwbGljZShpLCAxKTtcclxuICAgICAgaS0tO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVVuZGVmaW5lZEFuZE51bGxPcHRpb25zKGxpc3Q6IEFycmF5PGFueT4pIHtcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuICAgIGlmIChsaXN0W2ldLnZhbHVlID09PSB1bmRlZmluZWQgfHwgbGlzdFtpXS52YWx1ZSA9PT0gbnVsbCApIHtcclxuICAgICAgbGlzdC5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGktLTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZFZhbHVlKHZhbHVlOiBhbnkpIHtcclxuICByZXR1cm4gKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09ICcnKSB8fCB2YWx1ZSA9PT0gZmFsc2U7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0V4dGVybmFsTGluayh1cmwpOiBib29sZWFuIHtcclxuICByZXR1cm4gdXJsID8gdXJsLnN0YXJ0c1dpdGgoJ2h0dHAnKSA6IGZhbHNlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gb3BlbkV4dGVybmFsTGluayh1cmwpOiB2b2lkIHtcclxuICB3aW5kb3cub3Blbih1cmwsICdfYmxhbmsnKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uICBnZXRGb3JtYXR0ZWRMaW5rKGxpbms6IHN0cmluZyk6IHN0cmluZyB7XHJcbiAgbGV0IGZvcm1hdHRlZExpbmsgPSAnJztcclxuICAvLyBSZXRpcmEgdG9kb3Mgb3MgcG9udG9zIG5vIGNvbWXDp28gZGEgVVJMLlxyXG4gIGlmIChsaW5rKSB7XHJcbiAgICBmb3JtYXR0ZWRMaW5rID0gbGluay5yZXBsYWNlKC9eKFxcLikrL2csICcnKTtcclxuICB9XHJcbiAgLy8gVmVyaWZpY2Egc2UgZm9pIHV0aWxpemFkbyB1bWEgcm90YSBxdWUgbsOjbyBjb21lY2UgY29tIGJhcnJhLlxyXG4gIGlmICghZm9ybWF0dGVkTGluay5zdGFydHNXaXRoKCcvJykpIHtcclxuICAgIGZvcm1hdHRlZExpbmsgPSAnLycuY29uY2F0KGZvcm1hdHRlZExpbmspO1xyXG4gIH1cclxuICByZXR1cm4gZm9ybWF0dGVkTGluaztcclxufVxyXG5cclxuLyoqXHJcbiAqIE3DqXRvZG8gcmVzcG9uc8OhdmVsIHBvciBvcmRlbmFyIGRvaXMgdmFsb3Jlcy5cclxuICpcclxuICogQHBhcmFtIGxlZnRTaWRlIFByaW1laXJvIHZhbG9yIGEgc2VyIGNvbXBhcmFkby5cclxuICogQHBhcmFtIHJpZ2h0U2lkZSBTZWd1bmRvIHZhbG9yIGEgc2VyIGNvbXBhcmFkby5cclxuICogQHBhcmFtIGFzY2VuZGluZyBEZXRlcm1pbmEgc2Ugc2Vyw6EgZW0gb3JkZW0gYXNjZW5kZW50ZSBvdSBkZXNjZW5kZW50ZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzb3J0VmFsdWVzKGxlZnRTaWRlOiBzdHJpbmcsIHJpZ2h0U2lkZTogc3RyaW5nLCBhc2NlbmRpbmc6IGJvb2xlYW4gPSB0cnVlKTogbnVtYmVyIHtcclxuICBpZiAoYXNjZW5kaW5nKSB7XHJcbiAgICBpZiAobGVmdFNpZGUgPCByaWdodFNpZGUpIHtcclxuICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfSBlbHNlIGlmIChsZWZ0U2lkZSA+IHJpZ2h0U2lkZSkge1xyXG4gICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuICB9IGVsc2UgaWYgKGFzY2VuZGluZyA9PT0gZmFsc2UpIHtcclxuICAgIGlmIChsZWZ0U2lkZSA8IHJpZ2h0U2lkZSkge1xyXG4gICAgICByZXR1cm4gMTtcclxuICAgIH0gZWxzZSBpZiAobGVmdFNpZGUgPiByaWdodFNpZGUpIHtcclxuICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gMDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRGF0ZVJhbmdlKGRhdGU6IERhdGUsIGRhdGVTdGFydDogRGF0ZSwgZGF0ZUVuZDogRGF0ZSkge1xyXG4gIGlmIChkYXRlU3RhcnQgJiYgZGF0ZUVuZCkge1xyXG4gICAgcmV0dXJuIChkYXRlID49IGRhdGVTdGFydCAmJiBkYXRlIDw9IGRhdGVFbmQpO1xyXG4gIH0gZWxzZSBpZiAoZGF0ZVN0YXJ0ICYmICFkYXRlRW5kKSB7XHJcbiAgICByZXR1cm4gKGRhdGUgPj0gZGF0ZVN0YXJ0KTtcclxuICB9IGVsc2UgaWYgKCFkYXRlU3RhcnQgJiYgZGF0ZUVuZCkge1xyXG4gICAgcmV0dXJuIChkYXRlIDw9IGRhdGVFbmQpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjYXBpdGFsaXplRmlyc3RMZXR0ZXIodGV4dDogc3RyaW5nKTogc3RyaW5nIHtcclxuICByZXR1cm4gYCR7dGV4dC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKX0ke3RleHQuc2xpY2UoMSl9YDtcclxufVxyXG5cclxuLyoqXHJcbiAqIE1hcGVpYSB1bSBub3ZvIGFycmF5IGFwZW5hcyBjb20gYXMgcHJvcHJpZWRhZGVzIGRlZmluaWRhcyBwZWxvIGRlc2Vudm9sdmVkb3IgYmFzZWFkbyBlbSB1bSBhcnJheSBkZVxyXG4gKiBvcmlnZW0uXHJcbiAqXHJcbiAqIEV4ZW1wbG86XHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBjb25zdCBwZW9wbGUgPSBbXHJcbiAqICB7IGlkOiAxLCBuYW1lOiAnRnVsYW5vJywgYmlydGhkYXRlOiAnMTk4MC0xMS0wMScsIGdlbnJlOiAnTWFsZScsIGNpdHk6ICdTw6NvIFBhdWxvJywgZGVwZW5kZW50czogMiB9LFxyXG4gKiAgeyBpZDogMiwgbmFtZTogJ0JlbHRyYW5vJywgYmlydGhkYXRlOiAnMTk5Ny0wMS0yMScsIGdlbnJlOiAnRmVtYWxlJywgY2l0eTogJ0pvaW52aWxsZScsIGRlcGVuZGVudHM6IDAgfSxcclxuICogIHsgaWQ6IDMsIG5hbWU6ICdTaWNsYW5vJywgYmlydGhkYXRlOiAnMTk5NS0wNy0xNScsIGdlbnJlOiAnTWFsZScsIGNpdHk6ICdKb2ludmlsbGUnLCBkZXBlbmRlbnRzOiAwIH1cclxuICogXTtcclxuICpcclxuICogY29uc3QgcHJvcGVydGllcyA9IFsnaWQnLCAnbmFtZSddO1xyXG4gKlxyXG4gKiBjb25zdCBpZEFuZE5hbWUgPSBtYXBBcnJheUJ5UHJvcGVydGllcyhwZW9wbGUsIHByb3BlcnRpZXMpO1xyXG4gKlxyXG4gKiBjb25zb2xlLmxvZyhpZEFuZE5hbWUpOyAvLyBbeyBpZDogMSwgbmFtZTogJ0Z1bGFubycgfSwgeyBpZDogMiwgbmFtZTogJ0JlbHRyYW5vJyB9LCB7IGlkOiAzLCBuYW1lOiAnU2ljbGFubycgfV1cclxuICogYGBgXHJcbiAqXHJcbiAqIFVtIG91dHJvIHVzbyBwYXJhIG8gbcOpdG9kbyDDqSBcInBhcmVhclwiIHRvZG9zIG9zIG9iamV0b3MgZG8gYXJyYXkgY29tIGFzIG1lc21hcyBwcm9wcmllZGFkZXMuXHJcbiAqXHJcbiAqIGBgYFxyXG4gKiBjb25zdCBjdXN0b21lcnMgPSBbXHJcbiAqICB7IGlkOiAxLCBuYW1lOiAnRnVsYW5vJywgY2l0eTogJ1PDo28gUGF1bG8nLCBkZXBlbmRlbnRzOiAyIH0sIC8vIHNlbSBnZW5yZVxyXG4gKiAgeyBpZDogMiwgbmFtZTogJ0JlbHRyYW5vJywgZ2VucmU6ICdGZW1hbGUnLCBjaXR5OiAnSm9pbnZpbGxlJyB9LCAvLyBzZW0gZGVwZW5kZW50c1xyXG4gKiAgeyBpZDogMywgbmFtZTogJ1NpY2xhbm8nLCBnZW5yZTogJ01hbGUnLCBjaXR5OiAnSm9pbnZpbGxlJywgZGVwZW5kZW50czogMCB9XHJcbiAqIF07XHJcbiAqIGNvbnN0IHByb3BlcnRpZXMgPSBbJ2lkJywgJ25hbWUnLCAnY2l0eScsICdnZW5yZScsICdkZXBlbmRlbnRzJ107XHJcbiAqXHJcbiAqIGNvbnN0IHBhdHRlcm4gPSBtYXBBcnJheUJ5UHJvcGVydGllcyhjdXN0b21lcnMsIHByb3BlcnRpZXMpO1xyXG4gKiBjb25zb2xlLmxvZyhwYXR0ZXJuKTtcclxuICpcclxuICogLy8gW1xyXG4gKiAvLyAgIHsgaWQ6IDEsIG5hbWU6ICdGdWxhbm8nLCBjaXR5OiAnU8OjbyBQYXVsbycsIGdlbnJlOiB1bmRlZmluZWQsIGRlcGVuZGVudHM6IDIgfSxcclxuICogLy8gICB7IGlkOiAyLCBuYW1lOiAnQmVsdHJhbm8nLCBjaXR5OiAnSm9pbnZpbGxlJywgZ2VucmU6ICdGZW1hbGUnLCBkZXBlbmRlbnRzOiB1bmRlZmluZWQgfSxcclxuICogLy8gICB7IGlkOiAzLCBuYW1lOiAnU2ljbGFubycsIGNpdHk6ICdKb2ludmlsbGUnLCBnZW5yZTogJ01hbGUnLCBkZXBlbmRlbnRzOiAwIH1cclxuICogLy8gXVxyXG4gKiBgYGBcclxuICpcclxuICogQHBhcmFtIGl0ZW1zIHtBcnJheTxhbnk+fSBBcnJheSBkZSBpdGVtcyBvcmlnaW5hbC5cclxuICogQHBhcmFtIHByb3BlcnRpZXMge0FycmF5PHN0cmluZz59IEFycmF5IGRlIHN0cmluZyBjb20gYSBsaXN0YSBkZSBwcm9wcmllZGFkZXMgcXVlIGRldmVtIHNlciByZXRvcm5hZGFzLlxyXG4gKlxyXG4gKiBAcmV0dXJucyBBcnJheTxhbnk+XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gbWFwQXJyYXlCeVByb3BlcnRpZXMoaXRlbXM6IEFycmF5PGFueT4gPSBbXSwgcHJvcGVydGllczogQXJyYXk8c3RyaW5nPiA9IFtdKTogQXJyYXk8YW55PiB7XHJcbiAgcmV0dXJuIGl0ZW1zLm1hcChpdGVtID0+IG1hcE9iamVjdEJ5UHJvcGVydGllcyhpdGVtLCBwcm9wZXJ0aWVzKSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBNYXBlaWEgdW0gbm92byBvYmpldG8gYXBlbmFzIGNvbSBhcyBwcm9wcmllZGFkZXMgZGVmaW5pZGFzIHBlbG8gZGVzZW52b2x2ZWRvci5cclxuICpcclxuICogRXhlbXBsbzpcclxuICpcclxuICogYGBgXHJcbiAqIGNvbnN0IHBlcnNvbiA9IHsgaWQ6IDEsIG5hbWU6ICdGdWxhbm8nLCBiaXJ0aGRhdGU6ICcxOTgwLTExLTAxJywgZ2VucmU6ICdNYWxlJywgY2l0eTogJ1PDo28gUGF1bG8nLCBkZXBlbmRlbnRzOiAyIH07XHJcbiAqXHJcbiAqIGNvbnN0IHByb3BlcnRpZXMgPSBbJ2lkJywgJ25hbWUnXTtcclxuICpcclxuICogY29uc3QgaWRBbmROYW1lID0gbWFwT2JqZWN0QnlQcm9wZXJ0aWVzKHBlcnNvbiwgcHJvcGVydGllcyk7XHJcbiAqXHJcbiAqIGNvbnNvbGUubG9nKGlkQW5kTmFtZSk7IC8vIHsgaWQ6IDEsIG5hbWU6ICdGdWxhbm8nIH1cclxuICogYGBgXHJcbiAqXHJcbiAqIEBwYXJhbSBvYmplY3Qge0FycmF5PGFueT59IEFycmF5IGRlIGl0ZW1zIG9yaWdpbmFsLlxyXG4gKiBAcGFyYW0gcHJvcGVydGllcyB7QXJyYXk8c3RyaW5nPn0gQXJyYXkgZGUgc3RyaW5nIGNvbSBhIGxpc3RhIGRlIHByb3ByaWVkYWRlcyBxdWUgZGV2ZW0gc2VyIHJldG9ybmFkYXMuXHJcbiAqXHJcbiAqIEByZXR1cm5zIEFycmF5PGFueT5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBtYXBPYmplY3RCeVByb3BlcnRpZXMob2JqZWN0OiBhbnkgPSB7fSwgcHJvcGVydGllczogQXJyYXk8c3RyaW5nPiA9IFtdKSB7XHJcbiAgY29uc3QgZ2V0U2VsZWN0ZWRQcm9wZXJ0aWVzID0gKHNlbGVjdGVkUHJvcGVydGllcywgcHJvcGVydHkpID0+ICh7IC4uLnNlbGVjdGVkUHJvcGVydGllcywgW3Byb3BlcnR5XTogb2JqZWN0W3Byb3BlcnR5XSB9KTtcclxuXHJcbiAgcmV0dXJuIHByb3BlcnRpZXMucmVkdWNlKGdldFNlbGVjdGVkUHJvcGVydGllcywge30pO1xyXG59XHJcblxyXG4vKipcclxuICogUmV0b3JuYSBvcyB2YWxvcmVzIGRlIHVtIG9iamV0byBkZW50cm8gZGUgdW0gYXJyYXkuXHJcbiAqXHJcbiAqID4gU2ltdWxhIG8gT2JqZWN0LnZhbHVlcyhvYmopLCBvIG1lc21vIGRldmUgc2VyIHJlbW92aWRvIGFzc2ltIHF1ZSBhIHZlcnPDo28gdHlwZXNjcml0IGZvciBhdHVhbGl6YWRhLlxyXG4gKlxyXG4gKiBAcGFyYW0gb2JqZWN0IE9iamV0byBkZSBvbmRlIHNlcsOhIHBlZ28gb3MgdmFsb3Jlcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB2YWx1ZXNGcm9tT2JqZWN0KG9iamVjdDogYW55ID0ge30pOiBBcnJheTxhbnk+IHtcclxuICByZXR1cm4gT2JqZWN0LmtleXMob2JqZWN0KS5tYXAocHJvcGVydHkgPT4gb2JqZWN0W3Byb3BlcnR5XSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBhZGljaW9uYSAwIG5vIHRlbXBvIGluZm9ybWFkbywgY2FzbyBtZW5vciBxIDEwXHJcbiAqXHJcbiAqIEBwYXJhbSB0aW1lXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYWRkWmVybyh0aW1lOiBudW1iZXIpIHtcclxuICBpZiAoIXRpbWUpIHtcclxuICAgIHJldHVybiAnMDAnO1xyXG4gIH1cclxuXHJcbiAgaWYgKHRpbWUgPCAxMCkge1xyXG4gICAgcmV0dXJuIGAwJHt0aW1lfWA7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGltZTtcclxufVxyXG4iXX0=